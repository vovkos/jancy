//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

/*!

\class io.Serial

	\brief This class provides high-level asynchronous interface for accessing hardware or virtual serial ports.

	Serial ports are represented as *files* in most operating systems, so working with serial port looks pretty much the same as working with any other file stream. However, besides ``read`` and ``write`` operations serial port files also expose a set of serial-specific properties such as baud rate, status and control lines and so on.

	A typical sequence of steps when working with a serial port usually looks like this:

	* Assign your event handler using ``m_onSerialEvent`` (you would probably also want to *schedule* your event handler to be run in particular environment, e.g. in specific thread)
	* Open a serial port with ``open`` method;
	* Configure serial port settings (``m_baudRate``, ``m_dataBits`` etc)
	* When ``IncomingData`` event is fired, read from the serial port using ``read`` method;
	* Write to the serial port stream using ``write`` method;
	* Suspend writing if the return value of ``write`` is less than requested;
	* Resume writing on ``TransmitBufferReady`` event;
	* Close the serial port when no longer needed with ``close`` method.

	.. rubric:: Sample code:

	.. ref-code-block::

		class MyDialog
		{
			// ...

			io.Serial m_serial;

			construct ();

			open (
				char const* portName,
				uint_t baudRate
				);

			onWriteButtonClicked ();
			onSerialEvent (`io.SerialEventParams` const* params);
		}

		MyDialog.construct ()
		{
			// ...
			m_serial.m_onSerialEvent += onSerialEvent @ g_mainThreadScheduler;
		}

		MyDialog.open (
			char const* portName,
			uint_t baudRate
			)
		{
			m_serial.open (portName);
			m_serial.m_baudRate = baudRate;
			m_serial.m_dataBits = 8;
			m_serial.m_stopBits = `io.SerialStopBits._1`;
			// ...

		catch:
			// handle the error...
		}

		MyDialog.onWriteButtonClicked ()
		{
			static char data [] = "a quick brown fox jumps over the lazy dog";
			m_serial.write (data, sizeof (data));
		}

		MyDialog.onSerialEvent (`io.SerialEventParams` const* params)
		{
			if (params.m_syncId != m_serial.m_syncId) // late event
				return;

			switch (params.m_code)
			{
			case `io.SerialEventCode.IncomingData`:
				char buffer [256];
				size_t size = m_serial.read (buffer, sizeof (buffer));
				// ...
				break;
			}
		}

	\sa `io.SerialEventParams`, `io.SerialEventCode`, `io.File`, `io.FileStream`

	\field m_isOpen

		Holds the open status for the serial port, i.e. ``true`` if opened; ``false`` otherwise.

	\field m_syncId

		Holds the synchronization ID for the serial port [#f3]_.

	\property m_baudRate

		This property is used for getting and setting [#f4]_ baud rate, i.e. the number of signal changes per second, which directly affects the speed of data transmission.

		Different hardware serial ports may or may not support some particular baud rates. Unfortunately, there is no reliable cross-platform method of building a list of supported baud rates, so the only way is to probe.

	\property m_flowControl

		This property is used for getting and setting [#f4]_ flow control, i.e. the protocol of attempted prevention of data loss during serial transmission which may happen when transmission side sends data faster than the receiving side is able to process it.

		See `io.SerialFlowControl` enumeration for the list of valid values.

	\property m_dataBits

		This property is used for getting and setting [#f4]_ byte size, i.e. the number of bits in each character transmitted over the serial line. Valid values range from ``5`` to ``8``; normally ``8`` data bits are used.

	\property m_stopBits

		This property is used for getting and setting [#f4]_ the number of serial stop bits, i.e. auxillary (non-data) bits sent at the end of each character to re-synchronize the receiver; normally 1 stop bit is used (designated by `io.SerialStopBits._1`)

		See `io.SerialStopBits` enumeration for the list of valid values.

	\property m_parity

		This property is used for getting and setting [#f4]_ serial parity control, i.e. the protocol of attempted error detection during serial transmission. The idea is to send an extra *parity* bit so that the total number of one's including data bits *and* this parity bit is always *odd* or always *even*.

		This, however, is a rather weak error detection method; usually it's much better to employ other checksums/hash checks after the data has been transmitted.

		See `io.SerialParity` for the list of valid values.

	\property m_statusLines

		This property is used for getting the values of serial status lines (``DSR``, ``CTS``, ``DCD``, ``RING``).

		The returned value is a combination of `io.SerialStatusLines` enumeration members, showing which status lines are high (or ``0`` if all are low).

	\property m_dtr

		This property is used for getting and setting [#f4]_ ``DTR`` (data-terminal-ready) serial control line.

	\property m_rts

		This property is used for getting and setting [#f4]_ ``RTS`` (ready-to-send) serial control line.

	\event m_onSerialEvent

		This event is fired whenever an event occurs on the serial port.

		For the list of possible events, refer to `io.SerialEventCode` enumeration.

		Event handler receives a single argument of type `io.SerialEventParams` which holds parameters of the particular event [#f3]_.

	\fn open

		Opens a serial port.

		The function accepts a single ``name`` argument, which specifies the name of the serial port device.

		Returns ``true`` on success. If serial port could not be opened, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.

	\fn close

		Closes a previously opened serial port, does nothing if the port is not opened. This function always succeeds.

		Sometimes it may be convenient to use *disposable* pattern to ensure timely invokation of ``close`` [#f2]_.

	\fn read

		Attempts to read up to ``size`` bytes from the serial port into the buffer pointed to by ``p``.

		Returns the actual amount of bytes read on success. If read operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

		Normally you would call this function from within your event handler for ``IncomingData`` event. If this function is called when there is no incoming data, it blocks until either the data arrives, or the serial port is closed.

	\fn write

		Attempts to write ``size`` bytes from the buffer pointed to by ``p`` to the serial port.

		Returns the actual amount of bytes written on success. If write operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

		If the return value shows *less* bytes than specified by ``size`` argument, you should suspend further transmission until the file stream is ready to accept more data. When this happens, ``TransmitBufferReady`` event is fired and transmission could be resumed.

	\alias dispose
		Effectively makes ``io.Serial`` a *disposable* class [#f2]_.

	\footnote f3

		|footnote-sync-id|

	\footnote f4

		|footnote-set-property-fail|

	\footnote f1

		|footnote-errorcode|

	\footnote f2

		|footnote-disposable|

*/
