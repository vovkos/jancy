.. include:: def.rst
.. index:: pair: class; sys.NotificationEvent
.. _doxid-type_sys_notificationevent:

class sys.NotificationEvent
===========================

.. toctree::
	:hidden:

Overview
~~~~~~~~

This class provides standard means of synchronization between
threads. :ref:`More...<details-type_sys_notificationevent>`


.. ref-code-block:: jancy
	:class: doxyrest-overview-code-block

	import "sys_NotificationEvent.jnc"
	
	class NotificationEvent {
		// construction
	
		:target:`construct<doxid-function_sys_notificationevent_construct>`();
		:target:`destruct<doxid-function_sys_notificationevent_destruct>`();

		// methods
	
		void :ref:`signal<doxid-function_sys_notificationevent_signal>`();
		void :ref:`reset<doxid-function_sys_notificationevent_reset>`();
		bool :ref:`wait<doxid-function_sys_notificationevent_wait>`(:ref:`uint_t<doxid-typedef_uint_t>` timeout = -1);
	};
.. _details-type_sys_notificationevent:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~

This class provides standard means of synchronization between
threads.

Any object of this class can be in one of the following two states: *idle*
or *signalled*. One or more threads can wait until the event becomes
signalled by invoking ``wait`` method. When some other thread signals the
event by invoking ``signal`` method, *all* the waiging threads wake up, and
the event remains in *signalled* state.

To return event to *idle* state, use ``reset`` method.

Code sample::

	import "sys_NotificationEvent.jnc"

	sys.NotificationEvent g_event;

	thread1() {
		// ...

		g_event.wait(); // thread sleeps here until event is signalled

		// continue...
	}

	thread2() {
		// ...

		g_event.wait(); // thread sleeps here until event is signalled

		// continue...
	}

	thread3() {
		// ...

		g_event.signal(); // thread1 and thread2 wake up and continue;
		                    // g_event is still signalled

		// ...
		// if any other thread issues g_event.wait (), it will be satisfied
		// immediatly

		g_event.reset(); // not signalled anymore
	}



.. rubric:: See also:

`sys.Event`, `sys.Lock`, `sys.Thread`

Methods
-------

.. index:: pair: function; signal
.. _doxid-function_sys_notificationevent_signal:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void signal()

Sets event to *signalled* state. All the waiting threads wake up, the
event remains in *signalled* state.

.. index:: pair: function; reset
.. _doxid-function_sys_notificationevent_reset:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void reset()

Returns event to *idle* state.

.. index:: pair: function; wait
.. _doxid-function_sys_notificationevent_wait:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool wait(:ref:`uint_t<doxid-typedef_uint_t>` timeout = -1)

Waits until event goes to *signalled* state. When it happens, ``wait``
returns ``true`` but the event remains in *signalled* state.

If ``timeout`` parameter is not ``-1`` then it's a wait with a *time
limit*. If the event does not get signalled until timeout expires,
``wait`` return ``false``. Timeout is expressed in *milliseconds*.

