.. include:: def.rst
.. index:: pair: class; io.FileStream
.. _doxid-type_io_filestream:

class io.FileStream
===================

.. toctree::
	:hidden:

Overview
~~~~~~~~

This class provides high-level asynchronous streaming interface for
reading from and writing to files or devices. :ref:`More...<details-type_io_filestream>`


.. ref-code-block:: jancy
	:class: doxyrest-overview-code-block

	import "io_base.jncx"
	import "io_FileStream.jnc"
	
	class FileStream {
		// fields
	
		:ref:`io.FileStreamEvents<doxid-type_io_filestreamevents>` readonly volatile :target:`m_activeEvents<doxid-field_io_filestream_m_activeevents>`;
		:ref:`std.Error<doxid-type_std_error>` const* readonly volatile :target:`m_ioError<doxid-field_io_filestream_m_ioerror>`;
		bool readonly :ref:`m_isOpen<doxid-field_io_filestream_m_isopen>`;

		// properties
	
		:ref:`uint_t<doxid-typedef_uint_t>` autoget property :target:`m_readParallelism<doxid-property_io_filestream_m_readparallelism>`;
		:ref:`size_t<doxid-typedef_size_t>` autoget property :target:`m_readBlockSize<doxid-property_io_filestream_m_readblocksize>`;
		:ref:`size_t<doxid-typedef_size_t>` autoget property :target:`m_readBufferSize<doxid-property_io_filestream_m_readbuffersize>`;
		:ref:`size_t<doxid-typedef_size_t>` autoget property :target:`m_writeBufferSize<doxid-property_io_filestream_m_writebuffersize>`;
		:ref:`io.FileStreamOptions<doxid-type_io_filestreamoptions>` autoget property :target:`m_options<doxid-property_io_filestream_m_options>`;
		:ref:`uintptr_t<doxid-typedef_uintptr_t>` const property :target:`m_osHandle<doxid-property_io_filestream_m_oshandle>`;
		:ref:`io.FileKind<doxid-type_io_filekind>` const property :ref:`m_kind<doxid-property_io_filestream_m_kind>`;

		// construction
	
		:target:`construct<doxid-function_io_filestream_construct>`();
		:target:`destruct<doxid-function_io_filestream_destruct>`();

		// methods
	
		bool errorcode :ref:`open<doxid-function_io_filestream_open>`(
			:ref:`string_t<doxid-typedef_string_t>` name,
			:ref:`io.FileOpenFlags<doxid-type_io_fileopenflags>` flags = 0
		);
	
		void :ref:`close<doxid-function_io_filestream_close>`();
		void :ref:`unsuspend<doxid-function_io_filestream_unsuspend>`();
		bool errorcode :ref:`clear<doxid-function_io_filestream_clear>`();
	
		:ref:`size_t<doxid-typedef_size_t>` errorcode :ref:`read<doxid-function_io_filestream_read>`(
			void* p,
			:ref:`size_t<doxid-typedef_size_t>` size
		);
	
		:ref:`size_t<doxid-typedef_size_t>` errorcode :ref:`write<doxid-function_io_filestream_write>`(
			void const* p,
			:ref:`size_t<doxid-typedef_size_t>` size
		);
	
		long errorcode :target:`wait<doxid-function_io_filestream_wait>`(
			:ref:`io.FileStreamEvents<doxid-type_io_filestreamevents>` eventMask,
			void function* handler(io.FileStreamEvents triggeredEvents)
		);
	
		bool errorcode :target:`cancelWait<doxid-function_io_filestream_cancelwait>`(long handle);
	
		:ref:`io.FileStreamEvents<doxid-type_io_filestreamevents>` :target:`blockingWait<doxid-function_io_filestream_blockingwait>`(
			:ref:`io.FileStreamEvents<doxid-type_io_filestreamevents>` eventMask,
			:ref:`uint_t<doxid-typedef_uint_t>` timeout = -1
		);
	
		:ref:`io.FileStreamEvents<doxid-type_io_filestreamevents>` async :target:`asyncWait<doxid-function_io_filestream_asyncwait>`(:ref:`io.FileStreamEvents<doxid-type_io_filestreamevents>` eventMask);

		// aliases
	
		alias :ref:`dispose<doxid-alias_io_filestream_dispose>` = close;
	};
.. _details-type_io_filestream:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~

This class provides high-level asynchronous streaming interface for
reading from and writing to files or devices.

Besides all the standard methods of ``io.File`` (like ``open``, ``read``,
``write`` etc) ``io.FileStream`` also notifies its clients of events occured
on this file stream such as when data has arrived and could be read or when
IO error occured. This allows for clean and convenient asynchronous
event-driven IO programming.

A typical sequence of steps when working with a file stream looks something
like this:

* Open a file stream with ``open`` method;
* Assign IO event handler with ``wait`` method. You would probably also
  want to *schedule* your event handler to be run in particular
  environment(e.g., in a specific thread) and partially apply some
  syncrhonization ID to discard late events;
* When `io.FileStreamEvents.IncomingData` event is fired, read from the file
  using ``read`` method;
* Write to the file stream using ``write`` method;
* Suspend writing if the return value of ``write`` is less than requested;
* Resume writing on `io.FileStreamEvents.WriteBufferReady` event;
* Close the file stream when no longer needed with ``close`` method.

.. rubric:: Sample code:

.. ref-code-block::

	class MyDialog {
		// ...

		io.FileStream m_fileStream;
		uint_t m_syncId;

		void open(string_t fileName);
		void close();
		void waitFileStreamEvents();

		void onWriteButtonClicked();

		void onFileStreamEvent(
			uint_t syncId,
			`io.FileStreamEvents` triggeredEvents
		);
	}

	MyDialog.open(string_t fileName) {
		bool result = try m_fileStream.open(fileName);
		if (!result) {
			string_t errorString = std.getLastError().m_description;
			// ...
		}

		waitFileStreamEvents();
	}

	MyDialog.close() {
		m_fileStream.close();
		m_syncId++; // events past this point will be discarded as 'late'
	}

	MyDialog.waitFileStreamEvent() {
		`io.FileStreamEvents` eventMask =
			`io.FileStreamEvents.IoError` |
			`io.FileStreamEvents.IncomingData`;

		m_fileStream.wait(eventMask, onFileStreamEvent ~(++m_syncId) @
			g_mainThreadScheduler);
	}

	MyDialog.onWriteButtonClicked() {
		static char data[] = "a quick brown fox jumps over the lazy dog";
		m_fileStream.write(data, sizeof(data));
	}

	MyDialog.onFileStreamEvent(
		uint_t syncId,
		`io.FileStreamEvents` triggeredEvents
	) {
		if (syncId != m_syncId) // late event
			return;

		if (triggeredEvents & `io.FileStreamEvents.IoError`) {
			string_t errorString = m_fileStream.m_ioError.m_description;
			// ...
		}

		if (triggeredEvents & `io.FileStreamEvents.IncomingData`) {
			char buffer[256];
			size_t size = m_fileStream.read(buffer, sizeof(buffer));
			// ...
		}

		waitFileStreamEvents(); // restart wait
	}



.. rubric:: See also:

`io.FileStreamEvents`, `io.File`, `io.NamedPipe`, `io.Mailslot`

Fields
------

.. index:: pair: variable; m_isOpen
.. _doxid-field_io_filestream_m_isopen:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool readonly m_isOpen

Holds the open status for the file stream, i.e. ``true`` if opened;
``false`` otherwise.

Properties
----------

.. index:: pair: property; m_kind
.. _doxid-property_io_filestream_m_kind:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	:ref:`io.FileKind<doxid-type_io_filekind>` const property m_kind

Specifies the type of the file stream(regular disk file, serial port
etc). For the full list of supported file stream types, refer to
`io.FileKind`.

This field is currently only initialized on Windows. To to detect the
type ``io.FileStream`` uses WinAPI function ``GetFileType``.

Methods
-------

.. index:: pair: function; open
.. _doxid-function_io_filestream_open:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool errorcode open(
		:ref:`string_t<doxid-typedef_string_t>` name,
		:ref:`io.FileOpenFlags<doxid-type_io_fileopenflags>` flags = 0
	)

Opens or creates a file stream.

The function accepts two arguments. The first one, ``name`` specifies
the name of the file/device. The second one, ``flags``, can be used to
specify open options. Check `io.FileOpenFlags` for the complete list of
options.

Returns ``true`` on success. If the file stream could not be opened, IO
error supplied by operating system is set and then the function returns
``false`` [#f1]_.

.. index:: pair: function; close
.. _doxid-function_io_filestream_close:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void close()

Closes a previously opened file stream, does nothing if the file stream
is not opened. This function always succeeds.

Sometimes it may be convenient to use *disposable* pattern to ensure
timely invokation of ``close`` [#f2]_.

.. index:: pair: function; unsuspend
.. _doxid-function_io_filestream_unsuspend:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void unsuspend()

Accepted named pipes may initially be suspended (so that the user has
a chance to configure reading options such as ``m_readBlockSize``)

Call ``start`` to awaken the accepted pipe after it has been
configured.

.. index:: pair: function; clear
.. _doxid-function_io_filestream_clear:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool errorcode clear()

Clears the file, destroying all its contents. This function is only
applicable to regular disk file streams.

Returns ``true`` on success. If clear operation is unsuccessful, IO
error supplied by the operating system is set and then the function
returns ``false`` [#f1]_.

.. index:: pair: function; read
.. _doxid-function_io_filestream_read:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	:ref:`size_t<doxid-typedef_size_t>` errorcode read(
		void* p,
		:ref:`size_t<doxid-typedef_size_t>` size
	)

Attempts to read up to ``size`` bytes from the file strean into the
buffer pointed to by ``p``.

Returns the actual amount of bytes read on success. If read operation
is unsuccessful, IO error supplied by the operating system is set and
then the function returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler
for ``IncomingData`` event. If this function is called when there is
no incoming data, it blocks until either the data arrives, or the file
is closed.

.. index:: pair: function; write
.. _doxid-function_io_filestream_write:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	:ref:`size_t<doxid-typedef_size_t>` errorcode write(
		void const* p,
		:ref:`size_t<doxid-typedef_size_t>` size
	)

Attempts to write ``size`` bytes from the buffer pointed to by ``p``
into the file stream.

Returns the actual amount of bytes written on success. If write
operation is unsuccessful, IO error supplied by the operating system
is set and then the function returns ``-1`` [#f1]_.

If the return value shows *less* bytes than specified by ``size``
argument, you should suspend further transmission until the file stream
is ready to accept more data. When this happens, ``WriteBufferReady``
event is fired and transmission could be resumed.

Aliases
-------

.. index:: pair: alias; dispose
.. _doxid-alias_io_filestream_dispose:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	alias dispose = close

Effectively makes ``io.FileStream`` a *disposable* class [#f2]_.


---------------------

.. rubric:: Footnotes

.. [#f1]

	|footnote-errorcode|

.. [#f2]

	|footnote-disposable|

