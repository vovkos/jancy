//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

namespace jnc {

//! \addtogroup rtl-regex
//! @{

//..............................................................................

opaque class RegexMatch {
	uint64_t readonly m_offset;
	uint64_t readonly m_endOffset;
	size_t const property m_length;
	string_t const property m_text;

	construct();
	destruct();
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

size_t RegexMatch.m_length.get() const {
	return m_endOffset - m_offset;
}

//..............................................................................

bitflag enum RegexExecFlags {
	Stream,          // feed data chunk-by-chunk, then call jnc.Regex.eof()
	Reverse,         // run the reverse DFA to find the beginning of the match
	DisableReverse,  // don't run the reverse DFA to find beginnings of matches
	DisableCapture,  // don't capture sub-matches
	AnchorDataBegin, // match must start on the first byte of data
	AnchorDataEnd,   // match must end on the last byte of data
	ExactMatch = AnchorDataBegin | AnchorDataEnd,
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum RegexExecResult {
	Match              = 3,
	MatchOffsetsOnly   = 2,
	MatchEndOffsetOnly = 1,
	NoMatch            = 0,
	Continue           = -1, // continue feeding data
	ContinueBackward   = -2, // continue feeding backward data
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class RegexState {
	RegexExecFlags const property m_execFlags;
	RegexExecResult const property m_lastExecResult;
	size_t const property m_matchAcceptId;
	RegexMatch const* const property m_match;
	size_t const property m_captureCount;
	RegexMatch const* const property m_captureArray(size_t i); // 0 .. m_captureCount - 1
	RegexMatch const* const property m_groupArray(size_t i);   // 0 .. m_captureCount (0 yields the full match)

	construct();

	construct(
		RegexExecFlags execFlags,
		uint64_t offset = 0
	);

	destruct();

	void initialize(
		RegexExecFlags execFlags = 0,
		uint64_t offset = 0
	);

	void reset(uint64_t offset = 0);
	void resume();
}

//..............................................................................

bitflag enum RegexCompileFlags {
	CaseInsensitive,
	MatchOnly,       // don't demux NFA and no search start states
	DisableCapture,  // same as ExecFlag_NoCapture
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum RegexKind {
	Undefined,
	Single,
	Switch,
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum {
	RegexEof = -2
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class Regex {
	RegexKind readonly m_regexKind;

	construct();
	destruct();

	void clear();

	size_t errorcode load(
		void const* p,
		size_t size
	);

	std.Buffer* errorcode save() {
		std.Buffer buffer;
		save(buffer);
		return buffer;
	}

	bool errorcode compile(
		uint_t flags,
		string_t source
	);

	bool errorcode compile(string_t source) {
		return compile(0, source);
	}

	void createSwitch();

	bool errorcode compileSwitchCase(
		uint_t flags,
		string_t source
	);

	bool errorcode compileSwitchCase(string_t source) {
		return compileSwitchCase(0, source);
	}

	void finalizeSwitch(uint_t flags = 0);

	RegexExecResult exec(
		RegexState* state,
		string_t text
	) const;

	RegexExecResult exec(
		RegexState* state,
		char const* p,
		size_t length
	) const;

	RegexState* exec(
		RegexExecFlags flags,
		string_t text
	) const {
		RegexState state(flags);
		return exec(state, text) ? state : null;
	}

	RegexState* exec(
		RegexExecFlags flags,
		char const* p,
		size_t length
	) const {
		RegexState state(flags);
		return exec(state, p, length) ? state : null;
	}

	RegexState* exec(string_t text) const {
		return exec(0, text);
	}

	RegexState* exec(
		char const* p,
		size_t length
	) const {
		return exec(0, string_t(p, length));
	}

	RegexExecResult eof(
		RegexState* state,
		bool isLastExecDataAvailable
	);
}

//..............................................................................

//! @}

} // namespace jnc
