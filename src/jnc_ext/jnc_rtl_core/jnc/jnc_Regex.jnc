//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

namespace jnc {

//! \addtogroup rtl-regex
//! @{

//..............................................................................

opaque class RegexMatch {
	size_t readonly m_offset;
	size_t readonly m_endOffset;
	size_t const property m_length;
	char const* const property m_text;

	construct();
	destruct();
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

size_t RegexMatch.m_length.get() const {
	return m_endOffset - m_offset;
}

//..............................................................................

bitflag enum RegexExecFlags {
	Stream,          // feed data chunk-by-chunk, then call jnc.Regex.eof()
	Reverse,         // run the reverse DFA to find the beginning of the match
	DisableReverse,  // don't run the reverse DFA to find beginnings of matches
	DisableCapture,  // don't capture sub-matches
	AnchorDataBegin, // match must start on the first byte of data
	AnchorDataEnd,   // match must end on the last byte of data
	ExactMatch = AnchorDataBegin | AnchorDataEnd,
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum RegexExecResult {
	Match              = 3,
	MatchOffsetsOnly   = 2,
	MatchEndOffsetOnly = 1,
	NoMatch            = 0,
	Continue           = -1, // continue feeding data
	ContinueBackward   = -2, // continue feeding backward data
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class RegexState {
	RegexExecFlags const property m_execFlags;
	RegexExecResult const property m_lastExecResult;
	size_t const property m_matchAcceptId;
	RegexMatch const* const property m_match;
	size_t const property m_captureCount;
	RegexMatch const* const property m_captureArray(size_t i); // 0 .. m_captureCount - 1
	RegexMatch const* const property m_groupArray(size_t i);   // 0 .. m_captureCount (0 yields the full match)

	construct();

	construct(
		RegexExecFlags execFlags,
		size_t offset = 0
	);

	destruct();

	void initialize(
		RegexExecFlags execFlags = 0,
		size_t offset = 0
	);

	void reset(size_t offset = 0);
	void resume();
}

//..............................................................................

enum RegexCompileFlag {
	CaseInsensitive = 0x01,
	MatchOnly       = 0x02, // don't demux NFA and no search start states
	DisableCapture  = 0x04, // same as ExecFlag_NoCapture
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum RegexKind {
	Undefined,
	Single,
	Switch,
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum {
	RegexEof = -2
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class Regex {
	RegexKind readonly m_regexKind;

	construct();
	destruct();

	void clear();

	size_t errorcode load(
		void const* p,
		size_t size
	);

	std.Buffer* errorcode save() {
		std.Buffer buffer;
		save(buffer);
		return buffer;
	}

	bool errorcode compile(
		uint_t flags,
		char const* source,
		size_t length = -1
	);

	bool errorcode compile(
		char const* source,
		size_t length = -1
	) {
		return compile(0, source, length);
	}

	void createSwitch();

	bool errorcode compileSwitchCase(
		uint_t flags,
		char const* source,
		size_t length = -1
	);

	bool errorcode compileSwitchCase(
		char const* source,
		size_t length = -1
	) {
		return compileSwitchCase(0, source, length);
	}

	void finalizeSwitch(uint_t flags = 0);

	RegexExecResult exec(
		RegexState* state,
		char const* p,
		size_t length = -1
	) const;

	RegexState* exec(
		RegexExecFlags flags,
		char const* p,
		size_t length = -1
	) const {
		RegexState state(flags);
		return exec(state, p, length) ? state : null;
	}

	RegexState* exec(
		char const* p,
		size_t length = -1
	) const {
		return exec(0, p, length);
	}

	RegexExecResult eof(
		RegexState* state,
		bool isLastExecDataAvailable
	);
}

//..............................................................................

//! @}

} // namespace jnc
