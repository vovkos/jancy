//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "std_Buffer.jnc"

namespace jnc {

//! \addtogroup rtl-dylayout
//! @{

//..............................................................................

opaque class DynamicSectionGroup {
	size_t readonly m_sectionCount;
	DynamicSection* const property m_sectionArray(size_t index);

	construct();
	destruct();
}

//..............................................................................

enum DynamicSectionKind {
	Undefined,
	Struct,    // all regular fields are packed into structs
	Array,     // a non-const-sized array can't be part of a struct
	Field,     // a bitfield or a field with dynamic attributes
	Group,     // for grouping
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class DynamicSection: DynamicSectionGroup {
	DynamicSectionKind readonly m_sectionKind;
	size_t readonly m_offset;
	size_t readonly m_size;

	ModuleItemDecl* const property m_decl; // null for DynamicSectionKind.Struct
	Type* const property m_type;           // null for DynamicSectionKind.Group

	union {
		size_t readonly m_elementCount;    // for DynamicSectionKind.Array
		struct {                           // for DynamicSectionKind.Field
			uint_t readonly m_bitOffset;
			uint_t readonly m_bitCount;
		}
	}

	PtrTypeFlags readonly m_ptrTypeFlags;  // for DynamicSectionKind.Array & Field

	destruct();
}

//..............................................................................

bitflag enum DynamicLayoutMode {
	Save,   // otherwise, just parse (don't populate sections)
	Stream, // support incremental parsing (when dylayout is in a coroutine)
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class DynamicLayout: DynamicSectionGroup {
protected:
	// only for DynamicLayoutMode.Stream

	std.Buffer m_buffer;
	Promise* m_auxPromise; // to avoid extra allocations

public:
	Promise const* readonly m_promise;  // when async-waiting for resume()
	void const* readonly m_p;
	size_t readonly m_size;       // layout size (can be larger than buffer size)
	size_t readonly m_bufferSize; // size of the buffer being parsed
	size_t m_sizeLimit;           // freely adjustible (affects addStruct and addArray)

	DynamicLayoutMode readonly m_mode;

	bool const property m_isIncomplete {
		return m_size > m_bufferSize;
	}

	void const* const property m_end {
		return m_p + m_size;
	}

	construct() {
		init();
	}

	construct(
		DynamicLayoutMode mode,
		void const* p,
		size_t size
	) {
		init();
		reset(mode, p, size);
	}

	construct(
		void const* p,
		size_t size
	) {
		init();
		reset(0, p, size);
	}

	destruct();

	void clear() {
		reset(0, null, 0);
	}

	void reset(
		DynamicLayoutMode mode,
		void const* p,
		size_t size
	);

	void reset(
		void const* p,
		size_t size
	) {
		reset(0, p, size);
	}

	void updateGroupSizes(); // when accessing an incomplete layout (e.g. after an exception)

	// only for DynamicLayoutMode.Stream

	size_t resume(
		void const* p,
		size_t size
	);

	// suspend async stream layout until we see the delimiter (e.g., a string null-terminator)

	async size_t asyncScanTo(char c);

	async size_t asyncStrlen() {
		return await asyncScanTo(0);
	}

protected:
	void init();

	bool const property m_shouldAwait {
		return (m_mode & DynamicLayoutMode.Stream) && m_isIncomplete;
	}

	size_t errorcode addStruct(
		void thin* structType,
		bool isAsync
	);

	size_t errorcode addArray(
		void thin* decl,
		void thin* type,
		size_t elementCount,
		uint_t ptrTypeFlags,
		bool isAsync
	);

	size_t errorcode addField(
		void thin* decl,
		void thin* type,
		uint_t ptrTypeFlags,
		bool isAsync
	);

	// higher 56-bits - byte offset
	// lower 8-bits - bit offset

	uint64_t errorcode addBitField(
		void thin* decl,
		void thin* type,
		uint_t bitCount,
		uint_t ptrTypeFlags,
		bool isAsync
	);

	size_t openGroup(void thin* decl);
	void closeGroup();
	void closeGroups(size_t count);

	void cdecl setDynamicAttributes( // applies to the last decl
		size_t count,
		... // variant_t attr0, attr1, ...
	);
}

//..............................................................................

//! @}

} // namespace jnc
