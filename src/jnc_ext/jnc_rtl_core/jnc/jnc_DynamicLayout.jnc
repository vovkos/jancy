//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "std_Buffer.jnc"

namespace jnc {

//! \addtogroup rtl-dynamic-layout
//! @{

//..............................................................................

opaque class DynamicSectionGroup {
	size_t readonly m_sectionCount;
	DynamicSection* const property m_sectionArray(size_t index);

	construct();
	destruct();
}

//..............................................................................

enum DynamicSectionKind {
	Undefined,
	Struct,    // all regular fields are added to the tail struct section
	Array,     // non-const array fields
	Group,     // for grouping
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class DynamicSection: DynamicSectionGroup {
	DynamicSectionKind readonly m_sectionKind;
	size_t readonly m_offset;
	size_t readonly m_elementCount; // for DynamicSectionKind.Array

	Type* const property m_type;           // null for DynamicSectionKind.Group
	ModuleItemDecl* const property m_decl; // null for DynamicSectionKind.Struct
}

//..............................................................................

enum DynamicLayoutMode {
	Block,
	Stream,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class DynamicLayout: DynamicSectionGroup {
protected:
	// only for DynamicLayoutMode.Stream

	std.Buffer m_buffer;
	Promise* m_promise;    // pending section promise
	Promise* m_auxPromise; // to avoid extra allocations

public:
	void const* readonly m_p;
	size_t readonly m_size;       // layout size (can be larger than buffer size)
	size_t readonly m_bufferSize; // size of the buffer being parsed

	DynamicLayoutMode readonly m_mode;

	construct() {
		init();
	}

	construct(
		DynamicLayoutMode mode,
		void const* p,
		size_t size
	) {
		init();
		reset(mode, p, size);
	}

	construct(
		void const* p,
		size_t size
	) {
		init();
		reset(DynamicLayoutMode.Block, p, size);
	}

	destruct();

	bool const property m_isIncomplete {
		return m_size > m_bufferSize;
	}

	void clear() {
		reset(DynamicLayoutMode.Block, null, 0);
	}

	void reset(
		DynamicLayoutMode mode,
		void const* p,
		size_t size
	);

	void reset(
		void const* p,
		size_t size
	) {
		reset(DynamicLayoutMode.Block, p, size);
	}

	// only for DynamicLayoutMode.Stream

	size_t resume(
		void const* p,
		size_t size
	);

protected:
	void init();

	bool const property m_shouldAwait {
		return m_mode == DynamicLayoutMode.Stream && m_isIncomplete;
	}

	DynamicSection* addStruct(void thin* structType);

	DynamicSection* addArray(
		void thin* decl,
		void thin* type,
		size_t elementCount
	);

	DynamicSection* openGroup(void thin* decl);
	void closeGroup();
}

//..............................................................................

//! @}

} // namespace jnc
