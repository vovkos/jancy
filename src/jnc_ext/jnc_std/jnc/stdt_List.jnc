//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct ListLink<T> {
	friend List<T>;
	T cmut* readonly m_next;
	T cmut* readonly m_prev;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class List<T> {
	T* readonly m_head;
	T* readonly m_tail;
	size_t readonly m_count;

	void clear();
	void takeOver(List* list);

	void append(T* p) {
		insertTail(p);
	}

	void insertHead(T* p);
	void insertTail(T* p);

	void insertBefore(
		T* p,
		T* before
	);

	void insertAfter(
		T* p,
		T* after
	);

	void moveToHead(T* p) {
		remove(p);
		insertHead(p);
	}

	void moveToTail(T* p) {
		remove(p);
		insertTail(p);
	}

	void moveBefore(
		T* p,
		T* before
	) {
		remove(p);
		insertBefore(p, before);
	}

	void moveAfter(
		T* p,
		T* after
	) {
		remove(p);
		insertAfter(p, after);
	}

	T* removeHead();
	T* removeTail();
	void remove(T* p);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void List<T>.clear() {
	m_head = null;
	m_tail = null;
	m_count = 0;
}

void List<T>.takeOver(List* list) {
	m_head = list.m_head;
	m_tail = list.m_tail;
	m_count = list.m_count;
	list.clear();
}

void List<T>.insertHead(T* p) {
	p.m_prev = null;
	p.m_next = m_head;

	if (m_head)
		m_head.m_prev = p;
	else
		m_tail = p;

	m_head = p;
	m_count++;
}

void List<T>.insertTail(T* p) {
	p.m_next = null;
	p.m_prev = m_tail;

	if (m_tail)
		m_tail.m_next = p;
	else
		m_head = p;

	m_tail = p;
	m_count++;
}

void List<T>.insertBefore(
	T* p,
	T* before
) {
	if (!before)
		return insertTail(p);

	T* prev = before.m_prev;
	p.m_next = before;
	p.m_prev = prev;
	before.m_prev = p;

	if (prev)
		prev.m_next = p;
	else
		m_head = p;

	m_count++;
}

void List<T>.insertAfter(
	T* p,
	T* after
) {
	if (!after)
		return insertHead(p);

	T* next = after.m_next;
	p.m_prev = afterLink;
	p.m_next = next;
	afterLink.m_next = p;

	if (next)
		next.m_prev = p;
	else
		m_tail = p;

	m_count++;
}

T* List<T>.removeHead() {
	T* p = m_head;
	remove(p);
	return p;
}

T* List<T>.removeTail() {
	T* p = m_head;
	remove(p);
	return p;
}

void List<T>.remove(T* p) {
	T* next = p.m_next;
	T* prev = p.m_prev;

	if (prev)
		prev.m_next = next;
	else
		m_head = next;

	if (next)
		next.m_prev = prev;
	else
		m_tail = prev;

	m_count--;
	return it.m_p;
}

//..............................................................................

//! @}

} // namespace stdt
