//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct ListLink<T> {
	friend List;
	T cmut* readonly m_next;
	T cmut* readonly m_prev;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct IteratorBase<T> {
	typedef T Entry;

	T* readonly m_p;

	T* operator * () thin const {
		return m_p;
	}

	T* operator -> () thin const {
		return m_p;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct IteratorImpl<I>: I {
	construct(Entry* p = null) thin {
		m_p = p;
	}

	operator bool () thin const {
		return m_p != null;
	}

	IteratorImpl operator ++ () thin {
		m_p = m_p.m_next;
		return *this;
	}

	IteratorImpl postfix operator ++ () thin {
		IteratorImpl saved = *this;
		m_p = m_p.m_next;
		return saved;
	}

	IteratorImpl operator -- () thin {
		m_p = m_p.m_prev;
		return *this;
	}

	IteratorImpl postfix operator -- () thin {
		IteratorImpl saved = *this;
		m_p = m_p.m_prev;
		return saved;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

typedef IteratorImpl<IteratorBase<T> > Iterator<T>;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class List<
	T,
	I = Iterator<T>
> {
	typedef T Entry;
	typedef I Iterator;

	T cmut* readonly m_head;
	T cmut* readonly m_tail;
	size_t readonly m_count;

	void clear();
	void takeOver(List* list);

	Iterator append(T* p) {
		return insertTail(p);
	}

	Iterator insertHead(T* p);
	Iterator insertTail(T* p);

	Iterator insertBefore(
		T* p,
		Iterator beforeIt
	);

	Iterator insertAfter(
		T* p,
		Iterator afterIt
	);

	void moveToHead(Iterator it) {
		insertHead(remove(it));
	}

	void moveToTail(Iterator it) {
		insertTail(remove(it));
	}

	void moveBefore(
		Iterator it,
		Iterator beforeIt
	) {
		insertBefore(remove(it), beforeIt);
	}

	void moveAfter(
		Iterator it,
		Iterator afterIt
	) {
		insertAfter(remove(it), afterIt);
	}

	T* removeHead() {
		return remove(m_head);
	}

	T* removeTail() {
		return remove(m_tail);
	}

	T* remove(Iterator it);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void List<T, I>.clear() {
	m_head = null;
	m_tail = null;
	m_count = 0;
}

void List<T, I>.takeOver(List* list) {
	m_head = list.m_head;
	m_tail = list.m_tail;
	m_count = list.m_count;
	list.clear();
}

Iterator List<T, I>.insertHead(T* p) {
	p.m_prev = null;
	p.m_next = m_head;

	if (m_head)
		m_head.m_prev = p;
	else
		m_tail = p;

	m_head = p;
	m_count++;
	return p;
}

Iterator List<T, I>.insertTail(T* p) {
	p.m_next = null;
	p.m_prev = m_tail;

	if (m_tail)
		m_tail.m_next = p;
	else
		m_head = p;

	m_tail = p;
	m_count++;
	return p;
}

Iterator List<T, I>.insertBefore(
	T* p,
	Iterator beforeIt
) {
	if (!beforeIt)
		return insertTail(p);

	T* before = beforeIt.m_p;
	T* prev = before.m_prev;
	p.m_next = before;
	p.m_prev = prev;
	before.m_prev = p;

	if (prev)
		prev.m_next = p;
	else
		m_head = p;

	m_count++;
	return p;
}

Iterator List<T, I>.insertAfter(
	T* p,
	Iterator afterIt
) {
	if (!afterIt)
		return insertHead(p);

	T* after = afterIt.m_p;
	T* next = after.m_next;
	p.m_prev = after;
	p.m_next = next;
	after.m_next = p;

	if (next)
		next.m_prev = p;
	else
		m_tail = p;

	m_count++;
	return p;
}

T* List<T, I>.remove(Iterator it) {
	T* p = it.m_p;
	T* next = p.m_next;
	T* prev = p.m_prev;

	if (prev)
		prev.m_next = next;
	else
		m_head = next;

	if (next)
		next.m_prev = prev;
	else
		m_tail = prev;

	m_count--;
	return p;
}

//..............................................................................

//! @}

} // namespace stdt
