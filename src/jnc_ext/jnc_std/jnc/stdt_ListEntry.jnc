//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct ListEntry<T> {
	friend List;
	T constif* readonly m_next;
	T constif* readonly m_prev;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct IteratorBase<P> {
	typedef P EntryPtr;

	P readonly m_p;

	operator bool () thin const {
		return m_p != null;
	}

	P operator * () thin const {
		return m_p;
	}

	P operator -> () thin const {
		return m_p;
	}

	P operator ++ () thin {
		return m_p = m_p.m_next;
	}

	P operator -- () thin {
		return m_p = m_p.m_prev;
	}

	P postfix operator ++ () thin {
		P p0 = m_p;
		m_p = m_p.m_next;
		return p0;
	}

	P postfix operator -- () thin {
		P p0 = m_p;
		m_p = m_p.m_prev;
		return p0;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct IteratorImpl<M, C>: M {
	typedef ConstIteratorImpl<M, C> ConstIterator;

	construct() thin {}

	construct(EntryPtr p) thin {
		m_p = p;
	}
}

struct ConstIteratorImpl<M, C>: C {
	typedef IteratorImpl<M, C> Iterator;

	construct() thin {}

	construct(EntryPtr p) thin {
		m_p = p;
	}

	construct(Iterator it) thin {
		m_p = it.m_p;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

typedef IteratorImpl<
	IteratorBase<T*>,
	IteratorBase<T const*>
> Iterator<T>;

typedef ConstIteratorImpl<
	IteratorBase<T*>,
	IteratorBase<T const*>
> ConstIterator<T>;

//..............................................................................

struct BoxListEntry<T>: ListEntry<BoxListEntry> {
	typedef T Value;

	T m_value;

	construct() thin {}

	construct(T value) thin {
		m_value = value;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct BoxIteratorBase<T, P, E>: IteratorBase<E> {
	T operator * () thin const {
		return m_p.m_value;
	}

	P operator -> () thin const {
		return &m_p.m_value;
	}
}

struct BoxMutableIteratorBase<T, P, E>: BoxIteratorBase<T, P, E> {
	T operator := (T value) thin const {
		return m_p.m_value = value;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

typedef IteratorImpl<
	BoxMutableIteratorBase<T, T*, BoxListEntry<T>*>,
	BoxIteratorBase<T, T const*, BoxListEntry<T> const*>
> BoxIterator<T>;

typedef ConstIteratorImpl<
	BoxMutableIteratorBase<T, T*, BoxListEntry<T>*>,
	BoxIteratorBase<T, T const*, BoxListEntry<T> const*>
> BoxConstIterator<T>;

//..............................................................................

struct MapEntryBase<T, K, V>: ListEntry<T> {
	typedef K Key;
	typedef V Value;

	K readonly m_key;
	V m_value;
}

//..............................................................................

//! @}

} // namespace stdt
