//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "stdt_List.jnc"

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct BoxListEntry<T>: ListLink<BoxListEntry> {
	T m_value;

	construct() thin {}

	construct(T value) thin {
		m_value = value;
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct BoxIterator<T> {
	typedef BoxListEntry<T> Entry;
	Entry* readonly m_p;

	construct(Entry* p = null) thin {
		m_p = p;
	}

	operator bool () thin {
		return m_p != null;
	}

	T operator * () thin {
		return m_p.m_value;
	}

 	T operator := (T value) thin {
 		return m_p.m_value = value;
 	}

 	BoxIterator operator ++ () thin {
 		m_p = m_p.m_next;
 		return *this;
 	}

 	BoxIterator postfix operator ++ () thin {
 		BoxIterator saved = *this;
 		m_p = m_p.m_next;
 		return saved;
 	}

 	BoxIterator operator -- () thin {
 		m_p = m_p.m_prev;
 		return *this;
 	}

 	BoxIterator postfix operator -- () thin {
 		BoxIterator saved = *this;
 		m_p = m_p.m_prev;
 		return saved;
 	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class BoxList<T>: List<BoxListEntry<T> > {
	typedef BoxListEntry<T> Entry;
	typedef BoxIterator<T> Iterator;

	Iterator append(T value) {
		return insertTail(value);
	}

	Iterator insertHead(T value);
	Iterator insertTail(T value);

	void insertBefore(
		T value,
		Iterator beforeIt
	);

	void insertAfter(
		T value,
		Iterator afterIt
	);

	void moveToHead(Iterator it) {
		basetype.remove(it.m_p);
		basetype.insertHead(it.m_p);
	}

	void moveToTail(Iterator it) {
		basetype.remove(it.m_p);
		basetype.insertTail(it.m_p);
	}

	void moveBefore(
		Iterator it,
		Iterator beforeIt
	) {
		basetype.remove(it.m_p);
		basetype.insertBefore(it.m_p, beforeIt.m_p);
	}

	void moveAfter(
		Iterator it,
		Iterator afterIt
	) {
		basetype.remove(it.m_p);
		basetype.insertAfter(it.m_p, afterIt.m_p);
	}

	void remove(Iterator it) {
		basetype.remove(it.m_p);
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Iterator BoxList<T>.insertHead(T value) {
	Entry* p = new Entry(value);
	basetype.insertHead(p);
	return Iterator(p);
}

Iterator BoxList<T>.insertTail(T value) {
	Entry* p = new Entry(value);
	basetype.insertTail(p);
	return Iterator(p);
}

//..............................................................................

//! @}

} // namespace stdt
