//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "stdt_Map.jnc"

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct BinTreeNodeBase<T, K, V, P>: MapEntryBase<T, K, V> {
	friend BinTreeBase;
	friend BinTreeVisitRemoveImpl;

	typedef P Param;

	T constif* readonly m_parent;
	T constif* readonly m_left;
	T constif* readonly m_right;
	P readonly m_param;

	construct(K key) thin { // no default by intention (must derive from Base)
		basetype.construct(key);
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class BinTreeBase<T, C>: MapBase<T> {
	typedef C Cmp;

protected:
	T* m_root;
	C m_cmp;

public:
	void clear() {
		basetype.clear();
		m_root = null;
	}

	void takeOver(BinTreeBase* src);

	T constif* find(Key key) const?;

protected:
	static T* getLeftmostChild(T* p);
	static T* getRightmostChild(T* p);
	void rotateLeft(T* p);
	void rotateRight(T* p);
	T* replaceWithChild(T* p);

	T* insert(
		Key key,
		T* parent,
		int cmp
	);

	void exchange(
		T* prev,
		T* next
	);

	void rebalanceOnInsert(T* p) {}

	void rebalanceOnRemove(
		T* p,
		T* child
	) {}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

void BinTreeBase<T, C>.takeOver(BinTreeBase* src) {
	basetype.takeOver(src);
	m_root = src.m_root;
	src.m_root = null;
}

T constif* BinTreeBase<T, C>.find(Key key) const? {
	T constif* p = m_root;
	while (p) {
		int cmp = m_cmp(key, p.m_key);
		if (cmp == 0)
			return p;

		p = cmp < 0 ? p.m_left : p.m_right;
	}

	return null;
}

T* BinTreeBase<T, C>.getLeftmostChild(T* p) {
	while (p.m_left)
		p = p.m_left;

	return p;
}

T* BinTreeBase<T, C>.getRightmostChild(T* p) {
	while (p.m_right)
		p = p.m_right;

	return p;
}

void BinTreeBase<T, C>.rotateLeft(T* x) {
	T* y = x.m_right;
	assert(y);

	x.m_right = y.m_left;

	if (y.m_left)
		y.m_left.m_parent = x;

	y.m_parent = x.m_parent;

	if (!x.m_parent)
		m_root = y;
	else if (x == x.m_parent.m_left)
		x.m_parent.m_left = y;
	else
		x.m_parent.m_right = y;

	y.m_left = x;
	x.m_parent = y;
}

void BinTreeBase<T, C>.rotateRight(T* x) {
	T* y = x.m_left;
	assert(y);

	x.m_left = y.m_right;

	if (y.m_right)
		y.m_right.m_parent = x;

	y.m_parent = x.m_parent;

	if (!x.m_parent)
		m_root = y;
	else if (x == x.m_parent.m_right)
		x.m_parent.m_right = y;
	else
		x.m_parent.m_left = y;

	y.m_right = x;
	x.m_parent = y;
}

T* BinTreeBase<T, C>.replaceWithChild(T* p) {
	if (p.m_left && p.m_right) {
		assert(p.m_next == getLeftmostChild(p.m_right));
		assert(p.m_prev == getRightmostChild(p.m_left));

		exchange(p, p.m_next);
		assert(!p.m_left);

		// same effect:
		// exchange(p.m_prev, p);
		// assert(!p.m_right);
	}

	T* child = p.m_right ? p.m_right : p.m_left;
	if (!p.m_parent) {
		assert(p == m_root);
		m_root = child;
	} else if (p == p.m_parent.m_left)
		p.m_parent.m_left = child;
	else {
		assert(p == p.m_parent.m_right);
		p.m_parent.m_right = child;
	}

	if (child)
		child.m_parent = p.m_parent;

	m_list.remove(p);
	return child;
}

T* BinTreeBase<T, C>.insert(
	Key key,
	T* parent,
	int cmp
) {
	T* p = new T(key);
	p.m_parent = parent;

	if (!parent) {
		m_root = p;
		m_list.insertTail(p);
	} else if (cmp < 0) {
		parent.m_left = p;
		m_list.insertBefore(p, parent);
	} else {
		parent.m_right = p;
		m_list.insertAfter(p, parent);
	}

	return p;
}

void BinTreeBase<T, C>.exchange(
	T* prev,
	T* next
) {
	assert(prev != next.m_right);
	assert(next != prev.m_left);

	// special cases: direct parent-child relations

	if (prev == next.m_left) {
		T* oldLeft = prev.m_left;
		T* oldRight = prev.m_right;

		prev.m_left = next;
		prev.m_right = next.m_right;
		prev.m_parent = next.m_parent;

		next.m_left = oldLeft;
		next.m_right = oldRight;
		next.m_parent = prev;
	} else if (next == prev.m_right) {
		T* oldParent = prev.m_parent;
		T* oldLeft = prev.m_left;

		prev.m_left = next.m_left;
		prev.m_right = next.m_right;
		prev.m_parent = next;

		next.m_left = oldLeft;
		next.m_right = prev;
		next.m_parent = oldParent;
	} else {
		T* oldParent = prev.m_parent;
		T* oldLeft = prev.m_left;
		T* oldRight = prev.m_right;

		prev.m_left = next.m_left;
		prev.m_right = next.m_right;
		prev.m_parent = next.m_parent;

		next.m_left = oldLeft;
		next.m_right = oldRight;
		next.m_parent = oldParent;
	}

	// fixup parents

	if (!prev.m_parent)
		m_root = prev;
	else if (prev.m_parent.m_left == next)
		prev.m_parent.m_left = prev;
	else
		prev.m_parent.m_right = prev;

	if (!next.m_parent)
		m_root = next;
	else if (next.m_parent.m_left == prev)
		next.m_parent.m_left = next;
	else
		next.m_parent.m_right = next;

	// fixup children

	if (prev.m_left)
		prev.m_left.m_parent = prev;

	if (prev.m_right)
		prev.m_right.m_parent = prev;

	if (next.m_left)
		next.m_left.m_parent = next;

	if (next.m_right)
		next.m_right.m_parent = next;

	// exchange params

	Entry.Param tmp = prev.m_param;
	prev.m_param = next.m_param;
	next.m_param = tmp;
}

//..............................................................................

class BinTreeVisitRemoveImpl<T>: T {
public:
	Iterator visit(Key key);
	void remove(Iterator it);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Iterator BinTreeVisitRemoveImpl<T>.visit(Key key) {
	Entry* parent = null;
	Entry* p = m_root;
	int cmp;

	while (p) {
		cmp = m_cmp(key, p.m_key);
		if (cmp == 0)
			return p;

		parent = p;
		p = cmp < 0 ? p.m_left : p.m_right;
	}

	p = insert(key, parent, cmp);
	rebalanceOnInsert(p);
	return p;
}

void BinTreeVisitRemoveImpl<T>.remove(Iterator it) {
	Entry* p = *it;
	Entry* child = replaceWithChild(p);
	rebalanceOnRemove(p, child);
}

//..............................................................................

//! @}

} // namespace std
