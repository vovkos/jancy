//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "stdt_Map.jnc"

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct BinTreeNodeBase<T, K, V>: MapEntryBase<T, K, V> {
	friend BinTreeBase;
	friend BinTreeVisitRemoveImpl;

	T constif* readonly m_parent;
	T constif* readonly m_left;
	T constif* readonly m_right;

	construct(K key) thin { // intentionally no default
		basetype.construct(key);
	}

	void exchange(T* p) thin {}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class BinTreeBase<T, C>: MapBase<T> {
	typedef C Cmp;

protected:
	T* m_root;
	C m_cmp;

public:
	void clear() {
		basetype.clear();
		m_root = null;
	}

	T constif* find(Key key) const?;

protected:
	void rotateLeft(T* p);
	void rotateRight(T* p);

	T* insert(
		Key key,
		T* parent,
		int cmp
	);

	T* replaceWithChild(T* p);

	void exchange(
		T* p1,
		T* p2
	);

	void rebalanceOnInsert(T* p) {}

	void rebalanceOnRemove(
		T* p,
		T* child
	) {}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

T constif* BinTreeBase<T, C>.find(Key key) const? {
	T constif* p = m_root;
	while (p) {
		int cmp = m_cmp(key, p.m_key);
		if (cmp == 0)
			return p;

		p = cmp < 0 ? p.m_left : p.m_right;
	}

	return null;
}

T* BinTreeBase<T, C>.insert(
	Key key,
	T* parent,
	int cmp
) {
	T* p = new T(key);
	p.m_parent = parent;

	if (!parent) {
		m_root = p;
		m_list.insertTail(p);
	} else if (cmp < 0) {
		parent.m_left = p;
		m_list.insertBefore(p, parent);
	} else {
		parent.m_right = p;
		m_list.insertAfter(p, parent);
	}

	return p;
}

T* BinTreeBase<T, C>.replaceWithChild(T* p) {
	if (p.m_left && p.m_right) {
		// assert(p.m_next == getLeftmostChild(p.m_right));
		// assert(p.m_prev == getRightmostChild(p.m_left));
		exchange(p, p.m_next);
	}

	T* child = p.m_right ? p.m_right : p.m_left;
	if (!p.m_parent) {
		assert(p == m_root);
		m_root = child;
	} else if (p == p.m_parent.m_left)
		p.m_parent.m_left = child;
	else {
		assert(p == p.m_parent.m_right);
		p.m_parent.m_right = child;
	}

	if (child)
		child.m_parent = p.m_parent;

	m_list.remove(p);
	return child;
}

void BinTreeBase<T, C>.rotateLeft(T* x) {
	T* y = x.m_right;
	assert(y);

	x.m_right = y.m_left;

	if (y.m_left)
		y.m_left.m_parent = x;

	y.m_parent = x.m_parent;

	if (!x.m_parent)
		m_root = y;
	else if (x == x.m_parent.m_left)
		x.m_parent.m_left = y;
	else
		x.m_parent.m_right = y;

	y.m_left = x;
	x.m_parent = y;
}

void BinTreeBase<T, C>.rotateRight(T* x) {
	T* y = x.m_left;
	assert(y);

	x.m_left = y.m_right;

	if (y.m_right)
		y.m_right.m_parent = x;

	y.m_parent = x.m_parent;

	if (!x.m_parent)
		m_root = y;
	else if (x == x.m_parent.m_right)
		x.m_parent.m_right = y;
	else
		x.m_parent.m_left = y;

	y.m_right = x;
	x.m_parent = y;
}

void BinTreeBase<T, C>.exchange(
	T* p1,
	T* p2
) {
	T* oldParent = p1.m_parent;
	T* oldLeft = p1.m_left;
	T* oldRight = p1.m_right;

	// special cases: direct parent-child relations

	if (p1 == p2.m_left) {
		p1.m_left = p2;
		p1.m_right = p2.m_right;
		p1.m_parent = p2.m_parent;

		p2.m_left = oldLeft;
		p2.m_right = oldRight;
		p2.m_parent = p1;
	} else if (p1 == p2.m_right) {
		p1.m_left = p2.m_left;
		p1.m_right = p2;
		p1.m_parent = p2.m_parent;

		p2.m_left = oldLeft;
		p2.m_right = oldRight;
		p2.m_parent = p1;
	} else if (p2 == p1.m_left) {
		p1.m_left = p2.m_left;
		p1.m_right = p2.m_right;
		p1.m_parent = p2;

		p2.m_left = p1;
		p2.m_right = oldRight;
		p2.m_parent = oldParent;
	} else if (p2 == p1.m_right) {
		p1.m_left = p2.m_left;
		p1.m_right = p2.m_right;
		p1.m_parent = p2;

		p2.m_left = oldLeft;
		p2.m_right = p1;
		p2.m_parent = oldParent;
	} else {
		p1.m_left = p2.m_left;
		p1.m_right = p2.m_right;
		p1.m_parent = p2.m_parent;

		p2.m_left = oldLeft;
		p2.m_right = oldRight;
		p2.m_parent = oldParent;
	}

	// fixup parents

	if (!p1.m_parent)
		m_root = p1;
	else if (p1.m_parent.m_left == p2)
		p1.m_parent.m_left = p1;
	else
		p1.m_parent.m_right = p1;

	if (!p2.m_parent)
		m_root = p2;
	else if (p2.m_parent.m_left == p1)
		p2.m_parent.m_left = p2;
	else
		p2.m_parent.m_right = p2;

	// fixup children

	if (p1.m_left)
		p1.m_left.m_parent = p1;

	if (p1.m_right)
		p1.m_right.m_parent = p1;

	if (p2.m_left)
		p2.m_left.m_parent = p2;

	if (p2.m_right)
		p2.m_right.m_parent = p2;

	p1.exchange(p2);
}

//..............................................................................

class BinTreeVisitRemoveImpl<T>: T {
public:
	Iterator visit(Key key);
	void remove(Iterator it);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Iterator BinTreeVisitRemoveImpl<T>.visit(Key key) {
	Entry* parent = null;
	Entry* p = m_root;
	int cmp;

	while (p) {
		cmp = m_cmp(key, p.m_key);
		if (cmp == 0)
			return p;

		parent = p;
		p = cmp < 0 ? p.m_left : p.m_right;
	}

	p = insert(key, parent, cmp);
	rebalanceOnInsert(p);
	return p;
}

void BinTreeVisitRemoveImpl<T>.remove(Iterator it) {
	Entry* p = *it;
	Entry* child = replaceWithChild(p);
	rebalanceOnRemove(p, child);
}

//..............................................................................

//! @}

} // namespace std
