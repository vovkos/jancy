//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "stdt_Map.jnc"

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct BinTreeNodeBase<T, K, V>: MapEntryBase<T, K, V> {
	friend BinTreeBase;

	T constif* readonly m_parent;
	T constif* readonly m_left;
	T constif* readonly m_right;
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class BinTreeBase<T, C>: MapBase<T> {
	typedef C Cmp;

protected:
	T* m_root;
	C m_cmp;

public:
	construct(C cmp) {
		m_cmp = cmp;
	}

	void clear() {
		basetype.clear();
		m_root = null;
	}

	T constif* find(Key key) const?;
	Iterator visit(Key key);
	void remove(Iterator it);

protected:
	void exchange(
		T* p1,
		T* p2
	);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

T constif* BinTreeBase<T, C>.find(Key key) const? {
	T constif* p = m_root;
	while (p) {
		int cmp = m_cmp(key, p.m_key);
		if (cmp == 0)
			break;

		p = cmp < 0 ? p.m_left : p.m_right;
	}

	return p;
}

Iterator BinTreeBase<T, C>.visit(Key key) {
	T* parent = null;
	T* p = m_root;
	int cmp;

	while (p) {
		cmp = m_cmp(key, p.m_key);
		if (cmp == 0)
			return p;

		parent = p;
		p = cmp < 0 ? p.m_left : p.m_right;
	}

	p = new T;
	p.m_key = key;
	p.m_parent = parent;

	if (!parent) {
		m_root = p;
		m_list.insertTail(p);
	} else if (cmp < 0) {
		parent.m_left = p;
		m_list.insertBefore(p, parent);
	} else {
		parent.m_right = p;
		m_list.insertAfter(p, parent);
	}

	// rebalance on insert at p
}

void BinTreeBase<T, C>.remove(Iterator it) {
	T* p = *it;
	if (p.m_left && p.m_right) {
		T* next = (Node*)p.m_next;
		// asset(next == getLeftmostChild(p.m_right));
		exchange(p, next);
	}

	m_list.remove(p);
	// rebalance on remove at p
}

void BinTreeBase<T, C>.exchange(
	T* p1,
	T* p2
) {
	T* oldParent = p1.m_parent;
	T* oldLeft = p1.m_left;
	T* oldRight = p1.m_right;

	// special cases: direct parent-child relations

	if (p1 == p2.m_left) {
		p1.m_left = p2;
		p1.m_right = p2.m_right;
		p1.m_parent = p2.m_parent;

		p2.m_left = oldLeft;
		p2.m_right = oldRight;
		p2.m_parent = p1;
	} else if (p1 == p2.m_right) {
		p1.m_left = p2.m_left;
		p1.m_right = p2;
		p1.m_parent = p2.m_parent;

		p2.m_left = oldLeft;
		p2.m_right = oldRight;
		p2.m_parent = p1;
	} else if (p2 == p1.m_left) {
		p1.m_left = p2.m_left;
		p1.m_right = p2.m_right;
		p1.m_parent = p2;

		p2.m_left = p1;
		p2.m_right = oldRight;
		p2.m_parent = oldParent;
	} else if (p2 == p1.m_right) {
		p1.m_left = p2.m_left;
		p1.m_right = p2.m_right;
		p1.m_parent = p2;

		p2.m_left = oldLeft;
		p2.m_right = p1;
		p2.m_parent = oldParent;
	} else {
		p1.m_left = p2.m_left;
		p1.m_right = p2.m_right;
		p1.m_parent = p2.m_parent;

		p2.m_left = oldLeft;
		p2.m_right = oldRight;
		p2.m_parent = oldParent;
	}

	// fixup parents

	if (!p1.m_parent)
		m_root = p1;
	else if (p1.m_parent->m_left == p2)
		p1.m_parent->m_left = p1;
	else
		p1.m_parent->m_right = p1;

	if (!p2.m_parent)
		m_root = p2;
	else if (p2.m_parent->m_left == p1)
		p2.m_parent->m_left = p2;
	else
		p2.m_parent->m_right = p2;

	// fixup children

	if (p1.m_left)
		p1.m_left->m_parent = p1;

	if (p1.m_right)
		p1.m_right->m_parent = p1;

	if (p2.m_left)
		p2.m_left->m_parent = p2;

	if (p2.m_right)
		p2.m_right->m_parent = p2;

	T.onXcg(p1, p2);
}

//..............................................................................

struct RbTreeNode<K, V>: BinTreeNodeBase<RbTreeNode, K, V> {
	enum Color: uint8_t {
		Black = 0,
		Red   = 1
	};

	Color readonly m_color;

	static void onExchange(
		RbTreeNode* p1,
		RbTreeNode* p2
	) {
		Color tmp = p1.m_color;
		p1.m_color = p2.m_color;
		p2.m_color = tmp;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

typedef Iterator<RbTreeEntry<K, V> > RbTreeIterator<K, V>;
typedef ConstIterator<RbTreeEntry<K, V> > RbTreeConstIterator<K, V>;
typedef BoxList<RbTreeEntry<K, V>*> RbTreeBucket<K, V>;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class RbTree<K, V, C  = stdt.Cmp<K> >: BinTreeBase<RbTreeNode<K, V>, C> {
	construct(C cmp = C()) {
		basetype.construct(cmp);
	}
}

//..............................................................................

//! @}

} // namespace std

//..............................................................................

int main() {
	stdt.RbTree<int, int> map;
	map.clear();
	map.find(10);
	map.visit(10);
	return 0;
}

//..............................................................................
