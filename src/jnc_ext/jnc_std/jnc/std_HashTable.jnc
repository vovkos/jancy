//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

///+++

/// JNC_SELECT_ANY char g_std_HashTableSrc [] =

import "std_MapEntry.jnc"

namespace std {

//! \addtogroup container
//! @{

//..............................................................................

typedef size_t HashFunc (variant key);

typedef bool IsEqualFunc (
	variant key1,
	variant key2
	);

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

/**
	\import std_HashTable.jnc

	\brief This class provides a hash-table-based mapping from ``variant``-s to
	``variant``-s.

	``std.HashTable`` stores ``(key; value)`` pairs and provides fast lookup of
	the ``value`` associated with a ``key``.

	A typical sequence of steps when working with a hash table usually looks
	like this:

	* Add ``(key; value)`` pairs using ``add`` method (or by accessing the
	  *indexer* property);
	* Remove ``(key; value)`` pairs using ``remove`` or ``removeKey`` methods;
	* Find ``value`` associated with a ``key`` using ``find``, ``findValue``
	  method (or by accessing the *indexer* property).

	.. rubric:: Sample code:

	.. ref-code-block::

		enum State
		{
			Idle,
			Running,
			Stopping,
			_Count
		}

		std.HashTable hashTable;

		hashTable [State.Idle] = "idle";
		hashTable [State.Running] = "running";
		hashTable [State.Stopping] = "stopping";

		State state = (State) (rand () % State._Count);

		printf ($"state: $(hashTable [state])\n");
*/

opaque class HashTable
{
	MapEntry cmut* readonly m_head;
	MapEntry cmut* readonly m_tail;
	size_t readonly m_count;

	construct (
		HashFunc thin* hashFunc = null,
		IsEqualFunc thin* isEqualFunc = null
		);

	destruct ();

	/**
		Returns ``true`` if hash table is empty; ``false`` otherwise.
	*/

	bool const property m_isEmpty;

	bool m_isEmpty.get ()
	{
		return m_count == 0;
	}

	/**
		Provides a map-style access to the hash table. Reading from this
		property results in calling ``find`` method; writing to this property
		results in calling ``insert`` method.
	*/

	variant get (variant key)
	{
		return findValue (key, null);
	}

	set (
		variant key,
		variant value
		)
	{
		add (key, value);
	}

	/**
		Remove all entries from the hash table.
	*/

	clear ();

	MapEntry* errorcode visit (variant key);

	/**
		Looks up a value associated with the key ``key``.

		If the value is found, it is copied to the buffer pointed to by
		``value``; then ``find`` method returns ``true``.

		Returns ``false`` if key ``key`` is not found.
	*/

	MapEntry cmut* find (variant key) const;

	/**
		Looks up a value associated with the key ``key``.

		Returns the found value or ``undefinedValue`` if the value is not found.

		``undefinedValue`` must be chosen distinct from all the possible values
		in the hash table so it can be used as a *key-not-found* token.
	*/

	variant findValue (
		variant key,
		variant undefinedValue = null
		) const
	{
		MapEntry* entry = find (key);
		return entry ? entry.m_value : undefinedValue;
	}

	/**
		Adds a new ``(key; value)`` pair into the hash table.

		If ``key`` is already in the hash, ``insert`` re-writes the value of
		existing association with the new value specified by the ``value``
		argument.
	*/

	MapEntry* errorcode add (
		variant key,
		variant value
		)
	{
		MapEntry* entry = visit (key);
		entry.m_value = value;
		return entry;
	}

	void remove (MapEntry* entry);

	/**
		Finds and deletes ``key`` from the hash table.

		Returns ``true`` if ``key`` was found and ``(key; value)`` pair
		successfully deleted.

		Returns ``false`` if ``key`` was not found.
	*/

	bool removeKey (variant key)
	{
		MapEntry* entry = find (key);
		if (!entry)
			return false;

		remove (entry);
		return true;
	}
}

//..............................................................................

class StringHashTable: HashTable
{
	construct ()
	{
		basetype.construct (strdjb2, streq);
	}
}

class StringHashTableIgnoreCase: HashTable
{
	construct ()
	{
		basetype.construct (stridjb2, strieq);
	}
}

//..............................................................................

//! @}

} // namespace std

///;

///---
