//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "stdt_Array.jnc"
import "stdt_List.jnc"
import "stdt_Operator.jnc"

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct HashTableEntry<K, V>: MapEntryBase<HashTableEntry, K, V> {
	friend HashTable;

	typedef HashTableBucket<K, V> Bucket;

protected:
	Bucket* readonly m_bucket;
	Bucket.Iterator readonly m_bucketIt;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

typedef Iterator<HashTableEntry<K, V> > HashTableIterator<K, V>;
typedef ConstIterator<HashTableEntry<K, V> > HashTableConstIterator<K, V>;
typedef BoxList<HashTableEntry<K, V>*> HashTableBucket<K, V>;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class HashTable<K, V, H, E = Eq<K> > {
	typedef K Key;
	typedef V Value;
	typedef H Hash;
	typedef E Eq;
	typedef HashTableEntry<K, V> Entry;
	typedef HashTableIterator<K, V> Iterator;
	typedef HashTableConstIterator<K, V> ConstIterator;
	typedef HashTableBucket<K, V> Bucket;

	enum {
		InitialBucketCount = 32,
		ResizeThreshold    = 75,
	};

protected:
	List<Entry, Iterator> m_list;
	Array<Bucket*> m_table;
	H m_hash;
	E m_eq;

public:
	construct(
		H hash = H(),
		E eq = E()
	) {
		m_hash = hash;
		m_eq = eq;
	}

	V get(K key) const;

	V set(
		K key,
		V value
	) {
		add(key, value);
		return value;
	}

	property m_head {
		Entry cmut* get() {
			return m_list.m_head;
		}
	}

	property m_tail {
		Entry cmut* get() {
			return m_list.m_tail;
		}
	}

	size_t const property m_count {
		return m_list.m_count;
	}

	void clear() {
		m_list.clear();
		m_table.clear();
	}

	bool errorcode setBucketCount(size_t count);

	Iterator errorcode visit(K key);
	Entry cmut* find(K key) const;

	V findValue(
		K key,
		V undefinedValue = null
	) const {
		ConstIterator it = find(key);
		return it ? it->m_value : undefinedValue;
	}

	Iterator add(
		K key,
		V value
	);

	Iterator addIfNotExists(
		K key,
		V value
	);

	void remove(Iterator it);
	bool removeKey(K key);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

V HashTable<K, V, H, E>.get(K key) const {
	Iterator it = find(key);
	if (!it) {
		std.setError($"key not found");
		throw;
	}

	return it->m_value;
}

Iterator errorcode HashTable<K, V, H, E>.visit(K key) {
	if (!m_table.m_count)
		m_table.setCount(InitialBucketCount);

	size_t bucketIdx = m_hash(key) % m_table.m_count;
	Bucket* bucket = m_table[bucketIdx];
	if (!bucket)
		m_table[bucketIdx] = bucket = new Bucket;
	else
		for (Bucket.Iterator it = bucket.m_head; it; it++) {
			Entry* entry = *it;
			if (m_eq(key, entry.m_key))
				return entry;
		}

	Entry* entry = new Entry;
	entry.m_key = key;
	entry.m_bucket = bucket;
	entry.m_bucketIt = bucket.insertTail(entry);
	m_list.insertTail(entry);

	size_t loadFactor = (size_t)((uint64_t)m_list.m_count * 100 / m_table.m_count);
	if (loadFactor > ResizeThreshold)
		setBucketCount(m_table.m_count * 2);

	return entry;
}

Entry cmut* HashTable<K, V, H, E>.find(K key) const {
	if (!m_table.m_count)
		return null;

	size_t bucketIdx = m_hash(key) % m_table.m_count;
	Bucket* bucket = m_table[bucketIdx];
	if (!bucket)
		return null;

	for (Bucket.Iterator it = bucket.m_head; it; it++) {
		Entry* entry = *it;
		if (m_eq(key, entry.m_key))
			return entry;
	}

	return null;
}

Iterator HashTable<K, V, H, E>.add(
	K key,
	V value
) {
	Iterator it = visit(key);
	it->m_value = value;
	return it;
}

Iterator HashTable<K, V, H, E>.addIfNotExists(
	K key,
	V value
) {
	size_t prevCount = m_list.m_count;
	Iterator it = visit(key);
	if (m_list.m_count == prevCount)
		return null;

	it->m_value = value;
	return it;
}

void HashTable<K, V, H, E>.remove(Iterator it) {
	Entry* entry = *it;
	entry.m_bucket.remove(entry.m_bucketIt);
	entry.m_bucket = null;
	entry.m_bucketIt = null;
	m_list.remove(entry);
}

bool HashTable<K, V, H, E>.removeKey(K key) {
	Iterator it = find(key);
	if (!it)
		return false;

	remove(it);
	return true;
}

bool errorcode HashTable<K, V, H, E>.setBucketCount(size_t count) {
	m_table.clear();
	m_table.setCount(count);

	Iterator it = m_head;
	for (; it; it++) {
		Entry* entry = it.m_p;
		size_t bucketIdx = m_hash(entry.m_key) % count;
		Bucket* bucket = m_table[bucketIdx];
		if (!bucket)
			m_table[bucketIdx] = bucket = new Bucket;

		// use basetype to reuse all Bucket.Entry without reallocations
		Bucket.Entry* bucketEntry = entry.m_bucket.basetype.remove(entry.m_bucketIt);
		entry.m_bucketIt = bucket.basetype.insertTail(bucketEntry);
		entry.m_bucket = bucket;
	}

	return true;
}

//..............................................................................

//! @}

} // namespace stdt
