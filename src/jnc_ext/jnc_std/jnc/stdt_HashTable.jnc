//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "stdt_Map.jnc"
import "stdt_Array.jnc"
import "stdt_BoxList.jnc"

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct HashTableEntry<K, V>: MapEntryBase<HashTableEntry, K, V> {
	friend HashTableBase;

	typedef HashTableBucket<K, V> Bucket;

protected:
	Bucket* readonly m_bucket;
	Bucket.Iterator readonly m_bucketIt;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

typedef Iterator<HashTableEntry<K, V> > HashTableIterator<K, V>;
typedef ConstIterator<HashTableEntry<K, V> > HashTableConstIterator<K, V>;
typedef BoxList<HashTableEntry<K, V>*> HashTableBucket<K, V>;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class HashTable<K, V, H, E = Eq<K> >: MapImpl<HashTableBase<K, V, H, E> > {
	construct(
		H hash = H(),
		E eq = E()
	) {
		m_hash = hash;
		m_eq = eq;
	}
}

//..............................................................................

class HashTableBase<K, V, H, E>: MapBase<HashTableEntry<K, V> > {
	typedef H Hash;
	typedef E Eq;
	typedef HashTableBucket<K, V> Bucket;

	enum {
		InitialBucketCount = 32,
		ResizeThreshold    = 75,
	};

protected:
	Array<Bucket*> m_table;
	H m_hash;
	E m_eq;

public:
	void clear() {
		basetype.clear();
		m_table.clear();
	}

	Entry constif* find(K key) const?;
	Iterator errorcode visit(K key);
	void remove(Iterator it);
	bool errorcode setBucketCount(size_t count);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Entry constif* HashTableBase<K, V, H, E>.find(K key) const? {
	if (!m_table.m_count)
		return null;

	size_t bucketIdx = m_hash(key) % m_table.m_count;
	Bucket* bucket = m_table[bucketIdx];
	if (!bucket)
		return null;

	for (Bucket.Iterator it = bucket.m_head; it; it++) {
		Entry* entry = *it;
		if (m_eq(key, entry.m_key))
			return entry;
	}

	return null;
}

Iterator errorcode HashTableBase<K, V, H, E>.visit(K key) {
	if (!m_table.m_count)
		m_table.setCount(InitialBucketCount);

	size_t bucketIdx = m_hash(key) % m_table.m_count;
	Bucket* bucket = m_table[bucketIdx];
	if (!bucket)
		m_table[bucketIdx] = bucket = new Bucket;
	else
		for (Bucket.Iterator it = bucket.m_head; it; it++) {
			Entry* entry = *it;
			if (m_eq(key, entry.m_key))
				return entry;
		}

	Entry* entry = new Entry;
	entry.m_key = key;
	entry.m_bucket = bucket;
	entry.m_bucketIt = bucket.insertTail(entry);
	m_list.insertTail(entry);

	size_t loadFactor = (size_t)((uint64_t)m_list.m_count * 100 / m_table.m_count);
	if (loadFactor > ResizeThreshold)
		setBucketCount(m_table.m_count * 2);

	return entry;
}

void HashTableBase<K, V, H, E>.remove(Iterator it) {
	Entry* entry = *it;
	entry.m_bucket.remove(entry.m_bucketIt);
	entry.m_bucket = null;
	entry.m_bucketIt = null;
	m_list.remove(entry);
}

bool errorcode HashTableBase<K, V, H, E>.setBucketCount(size_t count) {
	m_table.clear();
	m_table.setCount(count);

	Iterator it = m_head;
	for (; it; it++) {
		Entry* entry = it.m_p;
		size_t bucketIdx = m_hash(entry.m_key) % count;
		Bucket* bucket = m_table[bucketIdx];
		if (!bucket)
			m_table[bucketIdx] = bucket = new Bucket;

		// use basetype to reuse all Bucket.Entry without reallocations
		Bucket.Entry* bucketEntry = entry.m_bucket.basetype.remove(entry.m_bucketIt);
		entry.m_bucketIt = bucket.basetype.insertTail(bucketEntry);
		entry.m_bucket = bucket;
	}

	return true;
}

//..............................................................................

//! @}

} // namespace stdt
