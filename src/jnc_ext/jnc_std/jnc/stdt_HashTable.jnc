//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

import "stdt_Map.jnc"
import "stdt_Array.jnc"
import "stdt_BoxList.jnc"

namespace stdt {

//! \addtogroup std-container
//! @{

//..............................................................................

struct HashTableEntry<K, V>: MapEntryBase<HashTableEntry, K, V> {
	friend HashTableBase;

	typedef BoxList<HashTableEntry*> Bucket;

protected:
	Bucket* readonly m_bucket;
	Bucket.Iterator readonly m_bucketIt;

	construct(K key = null) {
		basetype.construct(key);
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

typedef Iterator<HashTableEntry<K, V> > HashTableIterator<K, V>;
typedef ConstIterator<HashTableEntry<K, V> > HashTableConstIterator<K, V>;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class HashTable<K, V, H, E = Eq<K> >: MapImpl<HashTableBase<HashTableEntry<K, V>, H, E> > {
	construct(
		H hash = H(),
		E eq = E()
	) {
		m_hash = hash;
		m_eq = eq;
	}
}

//..............................................................................

class HashTableBase<T, H, E>: MapBase<T> {
	typedef H Hash;
	typedef E Eq;
	typedef BoxList<T*> Bucket;

	enum {
		InitialBucketCount = 32,
		ResizeThreshold    = 75,
	};

protected:
	Array<Bucket*> m_table;
	H m_hash;
	E m_eq;

public:
	void clear() {
		basetype.clear();
		m_table.clear();
	}

	void takeOver(HashTableBase* src) {
		basetype.takeOver(src);
		m_table.takeOver(&src.m_table);
	}

	T constif* find(Key key) const?;
	Iterator errorcode visit(Key key);
	void remove(Iterator it);
	bool errorcode setBucketCount(size_t count);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

T constif* HashTableBase<T, H, E>.find(Key key) const? {
	if (!m_table.m_count)
		return null;

	size_t bucketIdx = m_hash(key) % m_table.m_count;
	Bucket* bucket = m_table[bucketIdx];
	if (!bucket)
		return null;

	for (Bucket.Iterator it = bucket.m_head; it; it++) {
		T* p = *it;
		if (m_eq(key, p.m_key))
			return p;
	}

	return null;
}

Iterator errorcode HashTableBase<T, H, E>.visit(Key key) {
	if (!m_table.m_count)
		m_table.setCount(InitialBucketCount);

	size_t bucketIdx = m_hash(key) % m_table.m_count;
	Bucket* bucket = m_table[bucketIdx];
	if (!bucket)
		m_table[bucketIdx] = bucket = new Bucket;
	else
		for (Bucket.Iterator it = bucket.m_head; it; it++) {
			T* p = *it;
			if (m_eq(key, p.m_key))
				return p;
		}

	T* p = new T(key);
	p.m_bucket = bucket;
	p.m_bucketIt = bucket.insertTail(p);
	m_list.insertTail(p);

	size_t loadFactor = (size_t)((uint64_t)m_list.m_count * 100 / m_table.m_count);
	if (loadFactor > ResizeThreshold)
		setBucketCount(m_table.m_count * 2);

	return p;
}

void HashTableBase<T, H, E>.remove(Iterator it) {
	T* p = *it;
	p.m_bucket.remove(p.m_bucketIt);
	p.m_bucket = null;
	p.m_bucketIt = null;
	m_list.remove(p);
}

bool errorcode HashTableBase<T, H, E>.setBucketCount(size_t count) {
	m_table.clear();
	m_table.setCount(count);

	Iterator it = m_head;
	for (; it; it++) {
		T* p = it.m_p;
		size_t bucketIdx = m_hash(p.m_key) % count;
		Bucket* bucket = m_table[bucketIdx];
		if (!bucket)
			m_table[bucketIdx] = bucket = new Bucket;

		// use basetype to reuse all bucket entries and avoid gc allocations
		Bucket.Entry* bucketEntry = p.m_bucket.basetype.remove(p.m_bucketIt);
		p.m_bucket = bucket;
		p.m_bucketIt = bucket.basetype.insertTail(bucketEntry);
	}

	return true;
}

//..............................................................................

//! @}

} // namespace stdt
