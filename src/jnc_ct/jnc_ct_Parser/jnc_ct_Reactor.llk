//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

start
reactor_body
	local
	{
		SwitchStmt $stmt;
	}
	:	'{'
			{
				m_module->m_controlFlowMgr.switchStmt_Create (&$stmt);
				return m_module->m_controlFlowMgr.switchStmt_Condition (&$stmt, m_reactionIdxArgValue, $1.m_pos);
			}
		(reactor_stmt <&$stmt> | ';')+
		'}'
			{
				m_module->m_controlFlowMgr.switchStmt_Follow (&$stmt);
			}
	;

reactor_stmt <SwitchStmt* $stmt>
	enter
	{
		Value value (m_reactionIdx, m_module->m_typeMgr.getPrimitiveType (TypeKind_SizeT));
		return m_module->m_controlFlowMgr.switchStmt_Case ($stmt, value, m_currentToken.m_pos, 0);
	}
	:	local_item_declaration
	|	expression_stmt
	|	reactor_onevent_stmt
	;

reactor_onevent_stmt
	local
	{
		Declarator $declarator;
	}
	:	TokenKind_OnEvent reactor_event_name function_suffix <&$declarator> declaration_body_pass1
			{
				reactorOnEventStmt ($2.m_valueList, &$declarator, &$4.m_tokenList);
			}
	;

class
{
	sl::BoxList <Value> m_valueList;
}
reactor_event_name
	local
	{
		sl::BoxList <Token> $tokenList;
	}
	enter
	{
		ASSERT (m_stage == Stage_Reaction);
		m_stage = Stage_Pass2; // don't add implicit bindings to bindable properties inside 'onevent'
 	}
	leave
	{
		ASSERT (m_stage == Stage_Pass2);
		m_stage = Stage_Reaction; // restore
	}
	:	'(' expression_list ')'
			{
				sl::takeOver (&$.m_valueList, &$2.m_valueList)
			}
	|	TokenKind_BindingOf '(' expression ')'
			{
				Value value;
				return
					m_module->m_operatorMgr.getPropertyOnChanged ($3.m_value, &value) &&
					$.m_valueList.insertTail (value);
			}
	|	(any // anything until '('
			{
				$tokenList.insertTail ($1);
			}
		)+
			{
				Value value;
				return
					m_module->m_operatorMgr.parseExpression ($tokenList, &value) &&
					$.m_valueList.insertTail (value);
			}
	;

//..............................................................................

start
reactor_body_0
	:	'{' (reactor_stmt_0 | ';')+ '}'
	;

reactor_stmt_0
	leave
	{
		m_reactionIdx++;
	}
	:	local_item_declaration
	|	expression_0 ';'
	|	reactor_onevent_stmt_0
	;

reactor_onevent_stmt_0
	local
	{
		Declarator $declarator;
	}
	:	TokenKind_OnEvent reactor_event_name_0 function_suffix <&$declarator>
		reactor_compound_stmt_0
	;

reactor_compound_stmt_0
	:	'{' (reactor_compound_stmt_0 | any)* '}'
	;

reactor_event_name_0
	:	'(' expression_list_0 ')'
	|	TokenKind_BindingOf '(' expression_0 ')'
	|	any+ // anything until '('
	;

//..............................................................................
