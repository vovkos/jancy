//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

// root

named_type_specifier
	:	enum_specifier
	|	struct_specifier
	|	union_specifier
	|	resolver (TokenKind_Class TokenKind_Identifier) // vs type_specifier:TokenKind_Class
		class_specifier
	|	library_specifier
	;

named_type_specifier_sync
	:	TokenKind_Enum
	|	TokenKind_Struct
	|	TokenKind_Union
	|	TokenKind_Class
	|	TokenKind_BitFlagEnum
	|	TokenKind_OpaqueClass
	|	TokenKind_DynamicLib
	;

//..............................................................................

// enum

enum_specifier
	local {
		EnumType* $type;
	}
	:	(TokenKind_Enum $e | TokenKind_BitFlagEnum $b)
		TokenKind_Identifier $n?
		(':' type_name $t)?
			{
				uint_t flags = m_pragmaConfig.m_enumFlags;
				if (&$b)
					flags |= EnumTypeFlag_BitFlag;

				return ($type = createEnumType(
					&$n ? $n.m_pos : &$b ? $b.m_pos : $e.m_pos,
					&$n ? $n.m_data.m_string : sl::String(),
					&$t ? $t.m_type : NULL,
					flags
				)) != NULL;
			}
		(
				{
					m_module->m_namespaceMgr.openNamespace($type);
					$type->m_namespaceStatus = NamespaceStatus_Ready;
				}
			'{' enum_const_list '}'
				{
					m_module->m_namespaceMgr.closeNamespace();
					return finalizeEnumType($type);
				}
		|	TokenKind_Body $y
				{
					return
						setBody($type, $y) &&
						finalizeEnumType($type);
				}
		)
	;

start
nullable
enum_const_list
	:	enum_const catch (enum_const_sync) (',' enum_const)*
	;

nullable
enum_const
	:	attribute_block?
		TokenKind_Identifier $n ('=' expression_pass1 $i)?
			{
				return createEnumConst($n.m_pos, $n.m_data.m_string, &$i ? &$i.m_tokenList : NULL) != NULL;
			}
	|	epsilon
	;

enum_const_sync
	:	','
	|	'}'
	;

//..............................................................................

// struct

struct_specifier
	local {
		StructType* $type;
	}
	:	TokenKind_Struct
		(
			TokenKind_Identifier $n1?
			(':' type_name_list $b1)?
				{
					return ($type = createStructType(
						&$n1 ? $n1.m_pos : $1.m_pos,
						&$n1 ? $n1.m_data.m_string : sl::String(),
						&$b1 ? sl::ArrayRef<Type*>($b1.m_typeArray) : sl::ArrayRef<Type*>()
					)) != NULL;
				}
			derivable_type_member_block<$type>
		|	TokenKind_Identifier $n2
			template_suffix
			(':' type_name_list $b2)?
			declaration_body_pass1 $y
				{
					return declareTemplate(
						TypeKind_Struct,
						$n2,
						&$b2 ? sl::ArrayRef<Type*>($b2.m_typeArray) : sl::ArrayRef<Type*>(),
						&$y.m_tokenList
					) != NULL;
				}
		)
	;

//..............................................................................

// union

union_specifier
	local {
		UnionType* $type;
	}
	:	TokenKind_Union
		TokenKind_Identifier $n1? (
				{
					return ($type = createUnionType(
						&$n1 ? $n1.m_pos : $1.m_pos,
						&$n1 ? $n1.m_data.m_string : sl::String()
					)) != NULL;
				}
			derivable_type_member_block<$type>
		|	TokenKind_Identifier $n2
			template_suffix
			declaration_body_pass1 $y
				{
					return declareTemplate(
						TypeKind_Union,
						$n2,
						sl::ArrayRef<Type*>(),
						&$y.m_tokenList
					) != NULL;
				}

		)
	;

//..............................................................................

// class

class_specifier
	local {
		ClassType* $type;
	}
	:	(TokenKind_Class | TokenKind_OpaqueClass $o)
		TokenKind_Identifier $n (
			(':' type_name_list $b1)?
				{
					return ($type = createClassType(
						$n.m_pos,
						$n.m_data.m_string,
						&$b1 ? sl::ArrayRef<Type*>($b1.m_typeArray) : sl::ArrayRef<Type*>(),
						&$o ? ClassTypeFlag_Opaque : 0
					)) != NULL;
				}
			derivable_type_member_block<$type>
		|	template_suffix
			(':' type_name_list $b2)?
			declaration_body_pass1 $y
				{
					return !&$o ?
						declareTemplate(
							TypeKind_Class,
							$n,
							&$b2 ? sl::ArrayRef<Type*>($b2.m_typeArray) : sl::ArrayRef<Type*>(),
							&$y.m_tokenList
						) != 0 :
						err::fail("opaque class cannot be templated");
				}
		)
	;

//..............................................................................

// dynamiclib

library_specifier
	local {
		DynamicLibClassType* $type;
	}
	:	TokenKind_DynamicLib TokenKind_Identifier
			{
				return ($type = createDynamicLibType($2.m_pos, $2.m_data.m_string)) != NULL;
			}
		(
				{
					m_module->m_namespaceMgr.openNamespace($type->getLibNamespace());
				}
			'{' member_block_declaration_list '}'
				{
					m_module->m_namespaceMgr.closeNamespace();
					return finalizeDerivableType($type);
				}
		|	TokenKind_Body $y
				{
					return setBody($type->getLibNamespace(), $y);
				}
		)
	;

//..............................................................................

// struct, union, class

derivable_type_member_block<DerivableType* $type>
	:	(
				{
					m_module->m_namespaceMgr.openNamespace($type);
					$type->m_namespaceStatus = NamespaceStatus_Ready;
				}
			'{' member_block_declaration_list '}'
				{
					m_module->m_namespaceMgr.closeNamespace();
					return finalizeDerivableType($type);
				}
		|	TokenKind_Body $y
				{
					return
						setBody($type, $y) &&
						finalizeDerivableType($type);
				}
		)
	;

//..............................................................................
