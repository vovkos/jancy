//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

// qualified names

qualified_name_rslv
	:	TokenKind_Identifier ('.' TokenKind_Identifier)*
	;

struct {
	QualifiedName m_name;
}
qualified_name
	:	qualified_name_impl<&$.m_name>
	;

qualified_name_impl<QualifiedName* $name>
	:	TokenKind_Identifier
			{
				prepareQualifiedNameCodeAssistFallbackIf($1, *$name);
				$name->addName($1.m_data.m_string);
			}
		(
			'.' $d
				{
					prepareQualifiedNameCodeAssistFallbackIf($d, *$name);
				}
			TokenKind_Identifier $n
				{
					prepareQualifiedNameCodeAssistFallbackIf($n, *$name);
					$name->addName($n.m_data.m_string);
				}
		)*
	;

struct {
	sl::BoxList<QualifiedName> m_nameList;
}
qualified_name_list
	:	qualified_name
			{
				sl::BoxIterator<QualifiedName> it = $.m_nameList.insertTail();
				sl::takeOver(it.p(), &$1.m_name);
			}
		(
			',' qualified_name
				{
					sl::BoxIterator<QualifiedName> it = $.m_nameList.insertTail();
					sl::takeOver(it.p(), &$3.m_name);
				}
		)*
	;

start
qualified_name_save_name
	:	qualified_name
			{
				m_lastQualifiedName = $1.m_name;
			}
	;

//..............................................................................

// type names

nullable
type_name_rslv
	:	type_specifier_sync |
		type_modifier_sync |
		qualified_type_name_rslv
	;

struct {
	Type* m_type;
}
type_name
	: type_name_impl<&$.m_type, NULL>
	;

type_name_impl<
	Type** $type,
	Value* $countValue
>
	local {
		Declarator $declarator;
	}
	:	type_specifier_modifier_list
			{
				$declarator.setTypeSpecifier(&$1.m_typeSpecifier, m_module);
			}
		declarator_prefix<&$declarator>*
		declarator_suffix<&$declarator>*
			{
				Type* type = $declarator.calcType($countValue);
				if (!type)
					return false;

				*$type = type;
			}
	;

struct {
	sl::Array<Type*> m_typeArray;
}
type_name_list
	:	type_name
			{
				$.m_typeArray.append($1.m_type);
			}
		(
			',' type_name $t2
				{
					$.m_typeArray.append($t2.m_type);
				}
		)*
	;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct {
	sl::BoxList<Token> m_tokenList;
}
qualified_name_pass1
	:	qualified_name_pass1_atom<&$.m_tokenList> (
			'.' qualified_name_pass1_atom<&$.m_tokenList>
		)*
	;

qualified_name_pass1_atom<sl::BoxList<Token>* $tokenList>
	:	TokenKind_BaseType
			{
				$tokenList->insertTail(m_tokenPool->get($1));
			}
	|	TokenKind_Identifier
			{
				$tokenList->insertTail(m_tokenPool->get($1));
			}
		template_instantiate_operator_pass1<$tokenList>?
	;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// this will go away

struct {
	size_t m_baseTypeIdx;
	QualifiedName m_name;
	Token::Pos m_pos;
}
basetype_qualified_name
	enter {
		$.m_pos = m_tokenCursor->m_pos;
	}
	:	TokenKind_BaseType
			{
				$.m_baseTypeIdx = $1.m_data.m_integer - 1;
			}
	|	TokenKind_BaseType '.' qualified_name_impl<&$.m_name>
			{
				$.m_baseTypeIdx = $1.m_data.m_integer - 1;
			}
	|	qualified_name_impl<&$.m_name>
			{
				$.m_baseTypeIdx = -1;
			}
	;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// the main conflict of C-family: declaration vs expression

nullable
qualified_type_name_rslv
	enter {
		if (isTypeSpecified())
			return false;
	}
	:	resolver ({ return m_mode == Mode_Parse; })
		epsilon
	|	qualified_type_name_rslv_impl
	;

start
qualified_type_name_rslv_impl
	:	basetype_qualified_name
			{
				return findType(
					$1.m_baseTypeIdx,
					$1.m_name,
					$1.m_pos
				) != NULL;
			}
	;

struct {
	Type* m_type;
}
qualified_type_name
	:	resolver ({ return m_mode == Mode_Parse; })
		qualified_type_name_pt
			{
				$.m_type = $1.m_type;
			}
	|	qualified_type_name_ct
			{
				$.m_type = $1.m_type;
			}
	;

struct {
	Type* m_type;
}
qualified_type_name_pt
	:	basetype_qualified_name
			{
				return ($.m_type = getType(
					$1.m_baseTypeIdx,
					$1.m_name,
					$1.m_pos
				)) != NULL;
			}
	;

struct {
	Type* m_type;
}
qualified_type_name_ct
	:	basetype_qualified_name
			{
				return ($.m_type = getType(
					$1.m_baseTypeIdx,
					$1.m_name,
					$1.m_pos
				)) != NULL;
			}
	;

//..............................................................................
