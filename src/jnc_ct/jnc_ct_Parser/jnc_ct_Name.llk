//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

// qualified names

struct {
	ModuleItem* m_item;
}
qualified_name
	:	(
			TokenKind_BaseType
				{
					return ($.m_item = getBaseType($1.m_data.m_integer - 1)) != NULL;
				}
		|	TokenKind_Identifier $i1
				{
					return ($.m_item = lookupIdentifier($i1)) != NULL;
				}
		) (
			'.' TokenKind_Identifier $i2
				{
					return ($.m_item = lookupMember($.m_item, $i2)) != NULL;
				}
		|	'<' type_name_list $t '>'
				{
					return ($.m_item = instantiateTemplate($.m_item, $t.m_typeArray)) != NULL;
				}
		)*
	;

qualified_name_rslv
	:	(
			TokenKind_BaseType
		|	TokenKind_Identifier
		) (
			'.' TokenKind_Identifier
		|   template_instantiate_operator_pass1_rslv
		)*
	;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct {
	QualifiedName m_name;
}
qualified_name_pass1
	:	qualified_name_pass1_atom<&$.m_name> (
			'.' $d
				{
					prepareQualifiedNameCodeAssistFallbackIf($d, $.m_name);
				}
			qualified_name_pass1_atom<&$.m_name>
		)*
	;

qualified_name_pass1_atom<QualifiedName* $name>
	:	TokenKind_BaseType
			{
				prepareQualifiedNameCodeAssistFallbackIf($1, *$name);
				$name->addBaseType($1.m_data.m_integer - 1);
			}
	|	TokenKind_Identifier
			{
				prepareQualifiedNameCodeAssistFallbackIf($1, *$name);
				$name->addName($1.m_data.m_string);
			}
		(
			template_instantiate_operator_pass1<(*$name).getTemplateTokenList()>
				{
					$name->finalizeTemplateTokenList();
				}
		)?
	;

start
qualified_name_save
	:	qualified_name_pass1
			{
				sl::takeOver(&m_lastQualifiedName, &$1.m_name);
			}
	;

struct {
	sl::BoxList<QualifiedName> m_nameList;
}
qualified_name_list
	:	qualified_name_pass1
			{
				sl::BoxIterator<QualifiedName> it = $.m_nameList.insertTail();
				sl::takeOver(it.p(), &$1.m_name);
			}
		(
			',' qualified_name_pass1
				{
					sl::BoxIterator<QualifiedName> it = $.m_nameList.insertTail();
					sl::takeOver(it.p(), &$3.m_name);
				}
		)*
	;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// the main conflict of C-family: declaration vs expression

qualified_type_name_rslv
	enter {
		if (isTypeSpecified())
			return false;
	}
	:	resolver ({ return m_mode == Mode_Parse; })
		qualified_name_rslv
		(
			(',' | ';' | '=' | '(' | '[' | '{' | TokenKind_Body) // the name is a declarator
				{
					return false;
				}
		)?
	|	qualified_name
			{
				return isQualifiedTypeName($1.m_item);
			}
	;

struct {
	Type* m_type;
}
qualified_type_name
	local {
		lex::LineCol $pos;
	}
	enter {
		$pos = m_tokenCursor->m_pos;
	}
	:	resolver ({ return m_mode == Mode_Parse; })
		qualified_name_pass1
			{
				return ($.m_type = getQualifiedTypeName(&$1.m_name, $pos)) != NULL;
			}
	|	qualified_name
			{
				return ($.m_type = getQualifiedTypeName($1.m_item)) != NULL;
			}
	;

//..............................................................................

// type names

type_name_rslv
	:	type_specifier_sync
	|	type_modifier_sync
	|	qualified_type_name_rslv
	;

struct {
	Type* m_type;
}
type_name
	: type_name_impl<&$.m_type, NULL>
	;

type_name_impl<
	Type** $type,
	Value* $countValue
>
	local {
		Declarator $declarator;
	}
	:	type_specifier_modifier_list
			{
				$declarator.setTypeSpecifier(&$1.m_typeSpecifier, m_module);
			}
		declarator_prefix<&$declarator>*
		declarator_suffix<&$declarator>*
			{
				Type* type = $declarator.calcType($countValue);
				if (!type)
					return false;

				*$type = type;
			}
	;

struct {
	sl::Array<Type*> m_typeArray;
}
type_name_list
	:	type_name
			{
				$.m_typeArray.append($1.m_type);
			}
		(
			',' type_name $t2
				{
					$.m_typeArray.append($t2.m_type);
				}
		)*
	;

start
type_name_list_save
	: type_name_list
		{
			sl::takeOver(&m_lastTypeArray, &$1.m_typeArray);
		}
	;

//..............................................................................
