//..............................................................................
//
//  This file is part of the Jancy toolkit.
//
//  Jancy is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/jancy/license.txt
//
//..............................................................................

// qualified names

struct {
	ModuleItem* m_item;
}
qualified_name
	local {
		Value $value;
	}
	enter {
		m_module->m_controlFlowMgr.lockEmission(); // prevent member_operator from emitting code
	}
	leave {
		m_module->m_controlFlowMgr.unlockEmission();
	}
	:	(
			TokenKind_BaseType
				{
					return getBaseType($1.m_data.m_integer - 1, &$value);
				}
		|	TokenKind_Identifier $i
				{
					return lookupIdentifier($i, &$value);
				}
		)
		qualified_name_operator<&$value>*
			{
				if (!($.m_item = $value.getModuleItem()))
				return err::fail("qualified name does not refer to a module item");
			}
	;

qualified_name_operator<Value* $value>
	:	'.' member_operator<$value>
	|	template_instantiate_operator<$value>
	;

start
qualified_name_save_value
	:	qualified_name
			{
				m_lastDeclaredItem = $1.m_item;
			}
	;

qualified_name_rslv
	:	(TokenKind_BaseType | TokenKind_Identifier)
		(
			'.' TokenKind_Identifier
		|   template_instantiate_operator_pass1_rslv
		)*
	;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct {
	QualifiedNamePass1 m_name;
}
qualified_name_pass1
	:	qualified_name_pass1_atom<&$.m_name> (
			'.' $d
				{
					$.m_name.m_tokenList.insertTail(m_tokenPool->get($d));
				}
			qualified_name_pass1_atom<&$.m_name>
		)*
	;

qualified_name_pass1_atom<QualifiedNamePass1* $name>
	:	TokenKind_BaseType
			{
				$name->m_tokenList.insertTail(m_tokenPool->get($1));
			}
	|	TokenKind_Identifier
			{
				$name->m_tokenList.insertTail(m_tokenPool->get($1));
			}
		(
			template_instantiate_operator_pass1<&(*$name).m_tokenList>
				{
					$name->m_isTemplate = true;
				}
		)?
	;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// the main conflict of C-family: declaration vs expression

nullable
qualified_type_name_rslv
	enter {
		if (isTypeSpecified())
			return false;
	}
	:	resolver ({ return m_mode == Mode_Parse; })
		epsilon
	|	qualified_name
			{
				return $1.m_item->getItemKind() == ModuleItemKind_Type;
			}
	;

struct {
	Type* m_type;
}
qualified_type_name
	:	resolver ({ return m_mode == Mode_Parse; })
		qualified_name_pass1
			{
				$.m_type = getImportType($1.m_name);
			}
	|	qualified_name
			{
				if (($.m_type = (Type*)$1.m_item)->getItemKind() != ModuleItemKind_Type)
					return err::fail("qualified name does not refer to a type");
			}
	;

//..............................................................................

// legacy qualified names (will eventually go)

struct {
	QualifiedName m_name;
}
pure_qualified_name
	:	pure_qualified_name_impl<&$.m_name>
	;

pure_qualified_name_impl<QualifiedName* $name>
	:	TokenKind_Identifier
			{
				prepareQualifiedNameCodeAssistFallbackIf($1, *$name);
				$name->addName($1.m_data.m_string);
			}
		(
			'.' $d
				{
					prepareQualifiedNameCodeAssistFallbackIf($d, *$name);
				}
			TokenKind_Identifier $n
				{
					prepareQualifiedNameCodeAssistFallbackIf($n, *$name);
					$name->addName($n.m_data.m_string);
				}
		)*
	;

struct {
	sl::BoxList<QualifiedName> m_nameList;
}
qualified_name_list
	:	pure_qualified_name
			{
				sl::BoxIterator<QualifiedName> it = $.m_nameList.insertTail();
				sl::takeOver(it.p(), &$1.m_name);
			}
		(
			',' pure_qualified_name
				{
					sl::BoxIterator<QualifiedName> it = $.m_nameList.insertTail();
					sl::takeOver(it.p(), &$3.m_name);
				}
		)*
	;

start
qualified_name_save_name
	:	pure_qualified_name
			{
				m_lastQualifiedName = $1.m_name;
			}
	;

//..............................................................................

// type names

nullable
type_name_rslv
	:	type_specifier_sync |
		type_modifier_sync |
		qualified_type_name_rslv
	;

struct {
	Type* m_type;
}
type_name
	: type_name_impl<&$.m_type, NULL>
	;

type_name_impl<
	Type** $type,
	Value* $countValue
>
	local {
		Declarator $declarator;
	}
	:	type_specifier_modifier_list
			{
				$declarator.setTypeSpecifier(&$1.m_typeSpecifier, m_module);
			}
		declarator_prefix<&$declarator>*
		declarator_suffix<&$declarator>*
			{
				Type* type = $declarator.calcType($countValue);
				if (!type)
					return false;

				*$type = type;
			}
	;

struct {
	sl::Array<Type*> m_typeArray;
}
type_name_list
	:	type_name
			{
				$.m_typeArray.append($1.m_type);
			}
		(
			',' type_name $t2
				{
					$.m_typeArray.append($t2.m_type);
				}
		)*
	;

//..............................................................................
