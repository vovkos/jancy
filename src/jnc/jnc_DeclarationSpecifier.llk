//.............................................................................

class
{
	TypeSpecifier m_typeSpecifier;
}
declaration_specifier_list
	enter
	{
		pushTypeSpecifier (&$.m_typeSpecifier);
	}
	leave
	{
		popTypeSpecifier (&$.m_typeSpecifier);
	}
	:	declaration_specifier <&$.m_typeSpecifier>+
	;

declaration_specifier <TypeSpecifier* $typeSpecifier>
	:	attribute_block
	|	storage_specifier
			{
				return setStorageKind ($1.m_storageKind);
			}
	|	access_specifier
			{
				return setAccessKind ($1.m_accessKind);
			}
	|	type_specifier
			{
				return $typeSpecifier->setType ($1.m_type);
			}
	|	type_modifier
			{
				return $typeSpecifier->setTypeModifier ($1.m_typeModifier);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	TypeSpecifier m_typeSpecifier;
}
type_specifier_modifier_list
	enter
	{
		pushTypeSpecifier (&$.m_typeSpecifier);
	}
	leave
	{
		popTypeSpecifier (&$.m_typeSpecifier);
	}
	: type_specifier_modifier <&$.m_typeSpecifier>+
	;

type_specifier_modifier <TypeSpecifier* $typeSpecifier>
	:	type_specifier
			{
				return $typeSpecifier->setType ($1.m_type);
			}
	|	type_modifier
			{
				return $typeSpecifier->setTypeModifier ($1.m_typeModifier);
			}
	;

//.............................................................................

class
{
	StorageKind m_storageKind;
}
storage_specifier
	:	TokenKind_Typedef
			{
				$.m_storageKind = StorageKind_Typedef;
			}
	|	TokenKind_Alias
			{
				$.m_storageKind = StorageKind_Alias;
			}
	|	TokenKind_Static
			{
				$.m_storageKind = StorageKind_Static;
			}
	|	TokenKind_Thread
			{
				$.m_storageKind = StorageKind_Thread;
			}
	|	TokenKind_Stack
			{
				$.m_storageKind = StorageKind_Stack;
			}
	|	TokenKind_Heap
			{
				$.m_storageKind = StorageKind_Heap;
			}
	|	TokenKind_UHeap
			{
				// $.m_StorageKind = EStorage_UHeap;
				err::setFormatStringError ("manual memory management is not supported yet");
				return false;
			}
	|	TokenKind_Abstract
			{
				$.m_storageKind = StorageKind_Abstract;
			}
	|	TokenKind_Virtual
			{
				$.m_storageKind = StorageKind_Virtual;
			}
	|	TokenKind_Override
			{
				$.m_storageKind = StorageKind_Override;
			}
	|	TokenKind_Mutable
			{
				$.m_storageKind = StorageKind_Mutable;
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	AccessKind m_accessKind;
}
access_specifier
	:	TokenKind_Public
			{
				$.m_accessKind = AccessKind_Public;
			}
	|	TokenKind_Protected
			{
				$.m_accessKind = AccessKind_Protected;
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	Type* m_type;
}
type_specifier
	:	TokenKind_Void
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Void);
			}
	|	TokenKind_Variant
			{
				err::setStringError ("'variant' type specifier is not yet supported");
				return false;
			}
	|	TokenKind_Object
			{
				$.m_type = m_module->m_typeMgr.getStdType (StdType_ObjectClass);
			}
	|	TokenKind_Object '<' type_name '>'
			{
				$.m_type = m_module->m_typeMgr.getBoxClassType ($3.m_type);
			}
	|	TokenKind_Bool
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Bool);
			}
	|	TokenKind_Int8
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int8);
			}
	|	TokenKind_Int16
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int16);
			}
	|	TokenKind_Int32
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int32);
			}
	|	TokenKind_Int64
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int64);
			}
	|	TokenKind_Int
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int);
			}
	|	TokenKind_IntPtr
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Int_p);
			}
	|	TokenKind_Char
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Char);
			}
	|	TokenKind_Float
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Float);
			}
	|	TokenKind_Double
			{
				$.m_type = m_module->m_typeMgr.getPrimitiveType (TypeKind_Double);
			}
	|	TokenKind_Auto
			{
				err::setStringError ("'auto' type specifier is not yet supported");
				return false;
			}
	|	resolver (TokenKind_Property '{')
		property_template_specifier $t
			{
				$.m_type = $t.m_type;
			}
	|	resolver (qualified_type_name_rslv)
		qualified_type_name $t
			{
				$.m_type = $t.m_type;
			}
	;

// expression vs item_declaration_w_specifier

class 
{
	size_t m_baseTypeIdx;
	QualifiedName m_name;
}
basetype_qualified_name
	:	TokenKind_BaseType	
			{
				$.m_baseTypeIdx = $1.m_data.m_integer - 1;
			}
	|	TokenKind_BaseType '.' qualified_name_impl <&$.m_name>
			{
				$.m_baseTypeIdx = $1.m_data.m_integer - 1;
			}
	|	qualified_name_impl <&$.m_name>
			{
				$.m_baseTypeIdx = -1;
			}
	;

qualified_type_name_rslv
	:		{
				if (isTypeSpecified ())
					return false;
			}
		basetype_qualified_name $n
			{
				return 
					m_stage == StageKind_Pass1 || 
					findType (
						$n.m_baseTypeIdx,
						$n.m_name, 
						$n.m_firstToken.m_pos
						) != NULL;
			}
		('(' // we need this check if we are already in type_specifier_modifier_list
			{
				return false;
			}
		)?
	;

class
{
	Type* m_type;
}
qualified_type_name
	:	basetype_qualified_name
			{
				$.m_type = getType (
					$1.m_baseTypeIdx,
					$1.m_name, 
					$1.m_firstToken.m_pos
					);

				return $.m_type != NULL;
			}
	;

class
{
	PropertyType* m_type;
}
property_template_specifier
	local
	{
		PropertyTemplate* $propertyTemplate;
	}
	:	TokenKind_Property
			{
				$propertyTemplate = createPropertyTemplate ();
			}
		named_type_block <$propertyTemplate>
			{
				$.m_type = $propertyTemplate->calcType ();
				return $.m_type != NULL;
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	TypeModifier m_typeModifier;
}
type_modifier
	:	TokenKind_Unsigned
			{
				$.m_typeModifier = TypeModifier_Unsigned;
			}
	|	TokenKind_BigEndian
			{
				$.m_typeModifier = TypeModifier_BigEndian;
			}
	|	TokenKind_Const
			{
				$.m_typeModifier = TypeModifier_Const;
			}
	|	TokenKind_DConst
			{
				$.m_typeModifier = TypeModifier_DConst;
			}
	|	TokenKind_Volatile
			{
				$.m_typeModifier = TypeModifier_Volatile;
			}
	|	TokenKind_Weak
			{
				$.m_typeModifier = TypeModifier_Weak;
			}
	|	TokenKind_Thin
			{
				$.m_typeModifier = TypeModifier_Thin;
			}
	|	TokenKind_Safe
			{
				$.m_typeModifier = TypeModifier_Safe;
			}
	|	TokenKind_Cdecl
			{
				$.m_typeModifier = TypeModifier_Cdecl;
			}
	|	TokenKind_Stdcall
			{
				$.m_typeModifier = TypeModifier_Stdcall;
			}
	|	TokenKind_Thiscall
			{
				$.m_typeModifier = TypeModifier_Thiscall;
			}
	|	TokenKind_Jnccall
			{
				$.m_typeModifier = TypeModifier_Jnccall;
			}
	|	TokenKind_Array
			{
				$.m_typeModifier = TypeModifier_Array;
			}
	|	TokenKind_Function
			{
				$.m_typeModifier = TypeModifier_Function;
			}
	|	TokenKind_Property
			{
				$.m_typeModifier = TypeModifier_Property;
			}
	|	TokenKind_Bindable
			{
				$.m_typeModifier = TypeModifier_Bindable;
			}
	|	TokenKind_AutoGet
			{
				$.m_typeModifier = TypeModifier_AutoGet;
			}
	|	TokenKind_Indexed
			{
				$.m_typeModifier = TypeModifier_Indexed;
			}
	|	TokenKind_Multicast
			{
				$.m_typeModifier = TypeModifier_Multicast;
			}
	|	TokenKind_Event
			{
				$.m_typeModifier = TypeModifier_Event;
			}
	|	TokenKind_DEvent
			{
				$.m_typeModifier = TypeModifier_DEvent;
			}
	|	TokenKind_Reactor
			{
				$.m_typeModifier = TypeModifier_Reactor;
			}
	;

//.............................................................................
