//.............................................................................

class
{
	rtl::BoxList <Token> m_tokenList;
}
expression_pass1
	:	primary_expr_pass1 <&$.m_tokenList>+
	;

noast
primary_expr_pass1 <rtl::BoxList <Token>* $tokenList>
	:	'{'
			{
				$tokenList->insertTail ($1);
			}
		primary_expr_pass1 <$tokenList>*
		'}'
			{
				$tokenList->insertTail ($3);
			}
	|	'['
			{
				$tokenList->insertTail ($1);
			}
		primary_expr_pass1 <$tokenList>*
		']'
			{
				$tokenList->insertTail ($3);
			}
	|	'('
			{
				$tokenList->insertTail ($1);
			}
		primary_expr_pass1 <$tokenList>*
		')'
			{
				$tokenList->insertTail ($3);
			}
	|	any
			{
				$tokenList->insertTail ($1);
			}
	;

//.............................................................................

// arg list is simplier cause we only need to count parentheses

class
{
	rtl::BoxList <Token> m_tokenList;
}
arg_list_pass1
	:	'(' arg_pass1 <&$.m_tokenList>* ')'
	;

noast
arg_pass1 <rtl::BoxList <Token>* $tokenList>
	:	'('
			{
				$tokenList->insertTail ($1);
			}
		arg_pass1 <$tokenList>*
		')'
			{
				$tokenList->insertTail ($3);
			}
	|	any
			{
				$tokenList->insertTail ($1);
			}
	;

//.............................................................................

start
expression_save_value
	:	expression
			{
				m_expressionValue = $1.m_value;
			}
	;

start
nullable
expression_or_empty_list_save_list
	:	expression_or_empty_list
			{
				m_expressionValueList.takeOver (&$1.m_valueList);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	Value m_value;
}
start
expression
	enter
	{
		m_module->m_namespaceMgr.setSourcePos (m_currentToken.m_pos);
	}
	:	conditional_expr <&$.m_value>
	;

class
{
	Value m_value;
}
nullable
expression_or_empty
	:	conditional_expr <&$.m_value>
	|	epsilon
	;

class
{
	rtl::BoxList <Value> m_valueList;
}
expression_list
	:	expression
			{
				$.m_valueList.insertTail ($1.m_value);
			}
		(',' expression $e2
			{
				$.m_valueList.insertTail ($e2.m_value);
			}
		)*
	;

// expression_or_empty_list might seem overcomplicated but
// this is done to avoid having a singe EValue_Void in case of empty list

class
{
	rtl::BoxList <Value> m_valueList;
}
nullable
expression_or_empty_list
	:	expression
			{
				$.m_valueList.insertTail ($1.m_value);
			}
		(',' expression_or_empty $e2
			{
				$.m_valueList.insertTail ($e2.m_value);
			}
		)*
	|		{
				$.m_valueList.insertTail (Value ());
			}
		(',' expression_or_empty $e2
			{
				$.m_valueList.insertTail ($e2.m_value);
			}
		)+
	|	epsilon
	;

class
{
	Value m_value;
}
start
constant_expr
	:	conditional_expr <&$.m_value>
			{
				if ($.m_value.getValueKind () != ValueKind_Const)
				{
					err::setFormatStringError ("not a constant expression");
					return false;
				}
			}
	;

class
{
	intptr_t m_value;
}
start
constant_integer_expr
	:	expression
			{
				if ($1.m_value.getValueKind () != ValueKind_Const ||
					!($1.m_value.getType ()->getTypeKindFlags () & TypeKindFlag_Integer))
				{
					err::setFormatStringError ("not a constant integer expression");
					return false;
				}

				bool result = m_module->m_operatorMgr.castOperator (&$1.m_value, TypeKind_Int32);
				if (!result)
					return false;

				$.m_value = $1.m_value.getInt32 ();
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	Value m_trueValue;
	Value m_falseValue;
	BasicBlock* m_thenBlock;
	BasicBlock* m_elseBlock;
	BasicBlock* m_phiBlock;
}
conditional_expr <Value* $value>
	:	logical_or_expr <$value>
		(
				{
					$.m_thenBlock = m_module->m_controlFlowMgr.createBlock ("cond_then");
					$.m_elseBlock = m_module->m_controlFlowMgr.createBlock ("cond_else");
					$.m_phiBlock = m_module->m_controlFlowMgr.createBlock ("cond_phi");
					m_module->m_controlFlowMgr.conditionalJump (*$value, $.m_thenBlock, $.m_elseBlock);
				}
			'?'
			conditional_expr <&$.m_trueValue>
				{
					$.m_thenBlock = m_module->m_controlFlowMgr.setCurrentBlock ($.m_elseBlock); // might have changed
				}
			':'
			conditional_expr <&$.m_falseValue>
				{
					return m_module->m_operatorMgr.conditionalOperator (
						$.m_trueValue,
						$.m_falseValue,
						$.m_thenBlock,
						$.m_phiBlock,
						$value
						);
				}
		)?
	;

// important note: || and && operators are handled differently in reactor starter
// this is done not to skip bind-sites due to short-circuit evaluation
// however, this is a temporary solution: short circuit evaluation should be restored.
// bind-sites which can be potentially skipped during reactor starter should be 'flagged' 
// and if they are really skipped, then binding should be delayed until they are finally executed

logical_or_expr <Value* $value>
	local
	{
		BasicBlock* $opBlock1;
		BasicBlock* $opBlock2;
		Value $opValue2;
	}
	:	logical_and_expr <$value>
		(
			TokenKind_LogOr
				{
					if (m_stage != StageKind_ReactorStarter)
					{
						$opBlock1 = m_module->m_controlFlowMgr.getCurrentBlock ();
						$opBlock2 = m_module->m_controlFlowMgr.createBlock ("log_or_op2");
						m_module->m_controlFlowMgr.setCurrentBlock ($opBlock2); // don't follow yet
					}
				}
			logical_and_expr <&$opValue2>
				{
					if (m_stage != StageKind_ReactorStarter)
						return m_module->m_operatorMgr.logicalOrOperator ($opBlock1, $opBlock2, $value, $opValue2);
					else 
						return 
							m_module->m_operatorMgr.castOperator ($value, TypeKind_Bool) &&
							m_module->m_operatorMgr.castOperator (&$opValue2, TypeKind_Bool) &&
							m_module->m_operatorMgr.binaryOperator (BinOpKind_BwOr, $value, $opValue2);
				}
		)*
	;

logical_and_expr <Value* $value>
	local
	{
		BasicBlock* $opBlock1;
		BasicBlock* $opBlock2;
		Value $opValue2;
	}
	:	inclusive_or_expr <$value>
		(
			TokenKind_LogAnd
				{
					if (m_stage != StageKind_ReactorStarter)
					{
						$opBlock1 = m_module->m_controlFlowMgr.getCurrentBlock ();
						$opBlock2 = m_module->m_controlFlowMgr.createBlock ("log_and_op2");
						m_module->m_controlFlowMgr.setCurrentBlock ($opBlock2); // don't follow yet
					}
				}
			inclusive_or_expr <&$opValue2>
				{
					if (m_stage != StageKind_ReactorStarter)
						return m_module->m_operatorMgr.logicalAndOperator ($opBlock1, $opBlock2, $value, $opValue2);
					else 
						return 
							m_module->m_operatorMgr.castOperator ($value, TypeKind_Bool) &&
							m_module->m_operatorMgr.castOperator (&$opValue2, TypeKind_Bool) &&
							m_module->m_operatorMgr.binaryOperator (BinOpKind_BwAnd, $value, $opValue2);
				}
		)*
	;

inclusive_or_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	exclusive_or_expr <$value>
		('|' exclusive_or_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator (BinOpKind_BwOr, $value, $opValue2);
			}
		)*
	;

exclusive_or_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	and_expr <$value>
		('^' and_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator (BinOpKind_BwXor, $value, $opValue2);
			}
		)*
	;

and_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	equality_expr <$value>
		('&' equality_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator (BinOpKind_BwAnd, $value, $opValue2);
			}
		)*
	;

equality_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	relational_expr <$value>
		(equality_operator $o relational_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator ($o.m_opKind, $value, $opValue2);
			}
		)*
	;

class
{
	BinOpKind m_opKind;
}
equality_operator
	: TokenKind_Eq
		{
			$.m_opKind = BinOpKind_Eq;
		}
	| TokenKind_Ne
		{
			$.m_opKind = BinOpKind_Ne;
		}
	;

relational_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	shift_expr <$value>
		(relational_operator $o shift_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator ($o.m_opKind, $value, $opValue2);
			}
		)*
	;

class
{
	BinOpKind m_opKind;
}
relational_operator
	:	'<'
			{
				$.m_opKind = BinOpKind_Lt;
			}
	|	'>'
			{
				$.m_opKind = BinOpKind_Gt;
			}
	|	TokenKind_Le
			{
				$.m_opKind = BinOpKind_Le;
			}
	|	TokenKind_Ge
			{
				$.m_opKind = BinOpKind_Ge;
			}
	;

shift_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	additive_expr <$value>
		(shift_operator $o additive_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator ($o.m_opKind, $value, $opValue2);
			}
		)*
	;

class
{
	BinOpKind m_opKind;
}
shift_operator
	:	TokenKind_Shl
			{
				$.m_opKind = BinOpKind_Shl;
			}
	|	TokenKind_Shr
			{
				$.m_opKind = BinOpKind_Shr;
			}
	;

additive_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	multiplicative_expr <$value>
		(additive_operator $o multiplicative_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator ($o.m_opKind, $value, $opValue2);
			}
		)*
	;

class
{
	BinOpKind m_opKind;
}
additive_operator
	:	'+'
			{
				$.m_opKind = BinOpKind_Add;
			}
	|	'-'
			{
				$.m_opKind = BinOpKind_Sub;
			}
	;

multiplicative_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	at_expr <$value>
		(multiplicative_operator $o at_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator ($o.m_opKind, $value, $opValue2);
			}
		)*
	;

class
{
	BinOpKind m_opKind;
}
multiplicative_operator
	:	'*'
			{
				$.m_opKind = BinOpKind_Mul;
			}
	|	'/'
			{
				$.m_opKind = BinOpKind_Div;
			}
	|	'%'
			{
				$.m_opKind = BinOpKind_Mod;
			}
	;

at_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	:	assignment_expr <$value>
		('@' assignment_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator (BinOpKind_At, $value, $opValue2);
			}
		)*
	;

assignment_expr <Value* $value>
	: unary_expr <$value> assignment_operator_expr <$value>?
	;

assignment_operator_expr <Value* $value>
	local
	{
		Value $opValue2;
	}
	enter
	{
		if (m_stage == StageKind_ReactorStarter)  // reset on assignment
			m_reactorBindSiteList.clear ();
	}
	:	assignment_operator $o conditional_expr <&$opValue2>
			{
				return m_module->m_operatorMgr.binaryOperator ($o.m_opKind, $value, $opValue2);
			}
	|	'='
			{
				m_curlyInitializerTargetValue = *$value;
			}
		curly_initializer
	;

class
{
	BinOpKind m_opKind;
}
assignment_operator
	:	'='
			{
				$.m_opKind = BinOpKind_Assign;
			}
	|	TokenKind_RefAssign
			{
				$.m_opKind = BinOpKind_RefAssign;
			}
	|	TokenKind_AddAssign
			{
				$.m_opKind = BinOpKind_AddAssign;
			}
	|	TokenKind_SubAssign
			{
				$.m_opKind = BinOpKind_SubAssign;
			}
	|	TokenKind_MulAssign
			{
				$.m_opKind = BinOpKind_MulAssign;
			}
	|	TokenKind_DivAssign
			{
				$.m_opKind = BinOpKind_DivAssign;
			}
	|	TokenKind_ModAssign
			{
				$.m_opKind = BinOpKind_ModAssign;
			}
	|	TokenKind_ShlAssign
			{
				$.m_opKind = BinOpKind_ShlAssign;
			}
	|	TokenKind_ShrAssign
			{
				$.m_opKind = BinOpKind_ShrAssign;
			}
	|	TokenKind_AndAssign
			{
				$.m_opKind = BinOpKind_AndAssign;
			}
	|	TokenKind_XorAssign
			{
				$.m_opKind = BinOpKind_XorAssign;
			}
	|	TokenKind_OrAssign
			{
				$.m_opKind = BinOpKind_OrAssign;
			}
	;

unary_expr <Value* $value>
	:	postfix_expr <$value>
	|	unary_operator_expr <$value>
	;

unary_operator_expr <Value* $value>
	leave
	{
		if (m_stage == StageKind_ReactorStarter && isBindableType ($value->getType ()))
			return addReactorBindSite (*$value);
	}
	:	'+' unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_Plus, $value);
			}
	|	'-' unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_Minus, $value);
			}
	|	'~' unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_BwNot, $value);
			}
	|	'&' unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_Addr, $value);
			}
	|	'*' unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, $value);
			}
	|	'!' unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_LogNot, $value);
			}
	|	TokenKind_Inc unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_PreInc, $value);
			}
	|	TokenKind_Dec unary_expr <$value>
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_PreDec, $value);
			}
	|	TokenKind_Try
			{
				m_module->m_controlFlowMgr.lockThrow ();
			}
		unary_expr <$value>
			{
				m_module->m_controlFlowMgr.unlockThrow ();
			}
	|	resolver (cast_operator_rslv)
		TokenKind_Dynamic $d? '(' type_name $t ')' unary_expr <$value>
			{
				OperatorDynamism dynamism = isValidLocator ($d) ? OperatorDynamism_Dynamic : OperatorDynamism_Static;
				return m_module->m_operatorMgr.castOperator (dynamism, $value, $t.m_type);
			}
	|	TokenKind_New new_operator_type $t
			{
				return m_module->m_operatorMgr.newOperator (
					$t.m_type,
					$t.m_elementCountValue,
					&$t.m_argList,
					$value
					);
			}
		new_operator_curly_initializer <$value>?
	|	TokenKind_Delete unary_expr <$value>
			{
				err::setFormatStringError ("manual memory management is not supported yet");
				return false;
			}
	;

class
{
	Type* m_type;
	Value m_elementCountValue;
	rtl::BoxList <Value> m_argList;
}
new_operator_type
	:	type_name_impl <&$.m_type, &$.m_elementCountValue>
	|	resolver (type_name_w_constructor_rslv) priority (2) // set higher priority than type_specifier::qualified_name
		qualified_type_name $t TokenKind_Construct? '(' expression_or_empty_list $a ')'
			{
				$.m_type = $t.m_type;
				$.m_argList.takeOver (&$a.m_valueList);
			}
	;

type_name_w_constructor_rslv
	:	qualified_name TokenKind_Construct? '('
	;

new_operator_curly_initializer <Value* $value>
	enter
	{
		return m_module->m_operatorMgr.unaryOperator (UnOpKind_Indir, *$value, &m_curlyInitializerTargetValue);
	}
	:	curly_initializer
	;

// since '(' at 'unary_expr' is a conflict against epsilon production we need a resolver
// otherwise epsilon production (i.e. no more unary operators) always loses

cast_operator_rslv
	local
	{
		TypeSpecifier $typeSpecifier;
	}
	:	TokenKind_Dynamic? '(' type_specifier_modifier <&$typeSpecifier>
	;

postfix_expr <Value* $value>
	:	primary_expr <$value>
		postfix_operator <$value>*
	;

postfix_operator <Value* $value>
	leave
	{
		if (m_stage == StageKind_ReactorStarter && isBindableType ($value->getType ()))
			addReactorBindSite (*$value);
	}
	:	'(' expression_or_empty_list ')'
			{
				return m_module->m_operatorMgr.callOperator ($value, &$2.m_valueList);
			}
	|	'~' '(' expression_or_empty_list ')'
			{
				return m_module->m_operatorMgr.closureOperator ($value, &$3.m_valueList);
			}
	|	'[' expression_or_empty ']'
			{
				return m_module->m_operatorMgr.binaryOperator (BinOpKind_Idx, $value, $2.m_value);
			}
	|	TokenKind_Inc
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_PostInc, $value);
			}
	|	TokenKind_Dec
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_PostDec, $value);
			}
	|	'.'
		(TokenKind_Weak
			{
				return m_module->m_operatorMgr.weakenOperator ($value);
			}
		)?
		member_operator <$value>
	|	TokenKind_Ptr
			{
				return m_module->m_operatorMgr.unaryOperator (UnOpKind_Ptr, $value);
			}
		member_operator <$value>
	;

member_operator <Value* $value>
	:	TokenKind_Identifier $n
			{
				return m_module->m_operatorMgr.memberOperator ($value, $n.m_data.m_string);
			}
	|	TokenKind_Get
			{
				return m_module->m_operatorMgr.getPropertyGetter ($value);
			}
	|	TokenKind_Set
			{
				return m_module->m_operatorMgr.getPropertySetter ($value);
			}
	;

// sizeof typeof bindingof etc operators should be here and not in unary_operator
// otherwise member operators could not be applied (typeof (int).m_size)

primary_expr <Value* $value>
	leave
	{
		if (m_stage == StageKind_ReactorStarter && isBindableType ($value->getType ()))
			return addReactorBindSite (*$value);
	}
	:	'(' conditional_expr <$value> ')'
	|	literal <$value>
	|	TokenKind_BaseType
			{
				return getBaseType ($1.m_data.m_integer - 1, $value);
			}
	|	TokenKind_Identifier
			{
				return lookupIdentifier ($1.m_data.m_string, $1.m_pos, $value);
			}
	|	TokenKind_This
			{
				return m_module->m_operatorMgr.getThisValue ($value);
			}
	|	TokenKind_Integer
			{
				$value->setConstInt64_u ($1.m_data.m_int64_u);
			}
	|	TokenKind_Fp
			{
				$value->setConstDouble ($1.m_data.m_double);
			}
	|	TokenKind_True
			{
				$value->setConstBool (true);
			}
	|	TokenKind_False
			{
				$value->setConstBool (false);
			}
	|	TokenKind_Null
			{
				$value->setNull ();
			}
	|	TokenKind_Dynamic $d? TokenKind_SizeOf '(' type_name_or_expr $t ')'
			{
				OperatorDynamism dynamism = isValidLocator ($d) ? OperatorDynamism_Dynamic : OperatorDynamism_Static;
				return m_module->m_operatorMgr.sizeofOperator (dynamism, $t.m_value, $value);
			}
	|	TokenKind_Dynamic $d? TokenKind_CountOf '(' type_name_or_expr $t ')'
			{
				OperatorDynamism dynamism = isValidLocator ($d) ? OperatorDynamism_Dynamic : OperatorDynamism_Static;
				return m_module->m_operatorMgr.countofOperator (dynamism, $t.m_value, $value);
			}
	|	TokenKind_Dynamic $d? TokenKind_TypeOf '(' type_name_or_expr $t ')'
			{
				OperatorDynamism dynamism = isValidLocator ($d) ? OperatorDynamism_Dynamic : OperatorDynamism_Static;
				return m_module->m_operatorMgr.typeofOperator (dynamism, $t.m_value, $value);
			}
	|	TokenKind_OffsetOf '(' expression_0 $e ')'
			{
				return m_module->m_operatorMgr.offsetofOperator ($e.m_value, $value);
			}
	|	TokenKind_BindingOf '(' conditional_expr <$value> ')'
			{
				return m_module->m_operatorMgr.getPropertyOnChanged ($value);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	Value m_value;
}
type_name_or_expr
	:	type_name
			{
				$.m_value = $1.m_type;
			}
	|	expression
			{
				$.m_value = $1.m_value;
			}
	;

literal <Value* $value>
	local
	{
		Literal $literal;
	}
	:	literal_atom <&$literal>+ ('(' expression_or_empty_list $a ')')?
			{
				return finalizeLiteral (&$literal, isValidLocator ($a) ? &$a.m_valueList : NULL, $value);
			}
	;

literal_atom <Literal* $literal>
	:	TokenKind_Literal
			{
				$literal->m_binData.append ((const uchar_t*) $1.m_data.m_string.cc (), $1.m_data.m_string.getLength ());
				$literal->m_isZeroTerminated = true;
			}
	|	TokenKind_HexLiteral
			{
				$literal->m_binData.append ($1.m_data.m_binData, $1.m_data.m_binData.getCount ());
				$literal->m_isZeroTerminated = false;
			}
	|	TokenKind_FmtLiteral expression TokenKind_FmtSpecifier $s?
			{
				rtl::String fmtSpecifier = isValidLocator ($s) ? $s.m_data.m_string : rtl::String ();
				return addFmtSite (
					$literal, 
					(const uchar_t*) $1.m_data.m_string.cc (), 
					$1.m_data.m_string.getLength (),
					$2.m_value, 
					$1.m_data.m_integer != 0, 
					fmtSpecifier
					);
			}		
	;

//.............................................................................

start
curly_initializer
	local
	{
		CurlyInitializer $initializer;
	}
	enter
	{
		ASSERT (m_curlyInitializerTargetValue);

		$initializer.m_targetValue = m_curlyInitializerTargetValue;
		$initializer.m_index = 0;
		$initializer.m_count = 0;
	}
	:	'{' curly_initializer_item <&$initializer> (',' curly_initializer_item <&$initializer>)* '}'
			{
				if (!$initializer.m_count)
				{
					err::setFormatStringError ("empty curly initializer");
					return false;
				}
			}
	;

nullable
curly_initializer_item <CurlyInitializer* $initializer>
	local
	{
		Value prevCurlyInitializerTargetValue;
	}
	:	resolver (TokenKind_Identifier '=')
		TokenKind_Identifier $n '='
			{
				return prepareCurlyInitializerNamedItem ($initializer, $n.m_data.m_string);
			}
		(	curly_initializer
		|	expression $e
				{
					return m_module->m_operatorMgr.binaryOperator (BinOpKind_Assign, $initializer->m_memberValue, $e.m_value);
				}
		)
	|		{
				return prepareCurlyInitializerIndexedItem ($initializer);
			}
		expression $e
			{
				return m_module->m_operatorMgr.binaryOperator (BinOpKind_Assign, $initializer->m_memberValue, $e.m_value);
			}
	|		{
				return prepareCurlyInitializerIndexedItem ($initializer);
			}
		curly_initializer
	|	epsilon
			{
				return skipCurlyInitializerItem ($initializer);
			}
	;

//.............................................................................
