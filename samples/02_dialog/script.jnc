// This sample demonstrates reactive approach to UI programming.

//.............................................................................

// basic widget classes

class Widget
{
	bitflag enum SizePolicyFlag
	{
		Grow,
		Expand,
		Shrink,
		Ignore,
	}

	enum SizePolicy
	{
		Fixed = 0,
		Minimum = SizePolicyFlag.Grow,
		Maximum = SizePolicyFlag.Shrink,
		Preferred = SizePolicyFlag.Grow | SizePolicyFlag.Shrink,
		MinimumExpanding = SizePolicyFlag.Grow | SizePolicyFlag.Expand,
		Expanding = SizePolicyFlag.Grow| SizePolicyFlag.Shrink | SizePolicyFlag.Expand,
		Ignored = SizePolicyFlag.Shrink | SizePolicyFlag.Grow | SizePolicyFlag.Ignore
	}

	protected intptr m_handle;
	
	SizePolicy readonly m_hsizePolicy;
	SizePolicy readonly m_vsizePolicy;

	setSizePolicy (
		SizePolicy hpolicy,
		SizePolicy vpolicy
		);
	
	bool autoget property m_isVisible;
	bool autoget property m_isEnabled;
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class Layout
{
	enum Direction
	{
		LeftToRight, 
		RightToLeft, 
		TopToBottom, 
		BottomToTop,
	}	

	Direction readonly m_direction;
	
	addWidget (Widget* widget);
	addLayout (Layout* layout);
	addSpacer ();

	construct (Direction direction);
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class Label: Widget
{
	bitflag enum Alignment
	{
		Left,
		Right,
		HCenter,
		Justify,
		Absolute,
		Top,
		Bottom,
		VCenter,
	}

	char const* autoget property m_text;
	int autoget property m_color;
	int autoget property m_backColor;
	Alignment autoget property m_alignment;

	construct (char const* text);
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class Button: Widget
{
	char const* autoget property m_text;
	event m_onClicked ();

	construct (char const* text);
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class CheckBox: Widget
{
	char const* autoget property m_text;
	bool bindable property m_isChecked;

	construct (char const* text);
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class TextEdit: Widget
{
	char const* property m_text;

	construct ();
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

opaque class Slider: Widget
{
	int autoget property m_minimum;
	int autoget property m_maximum;
	int bindable property m_value;

	construct (
		int minimum = 0,
		int maximum = 100
		);
}

//.............................................................................

// ui widgets

Slider* g_redSlider;
Slider* g_greenSlider;
Slider* g_blueSlider;

int bindable g_color;

Label* g_colorLabel;

CheckBox* g_enablePrintCheckBox;
TextEdit* g_textEdit;
Button* g_printButton;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ui reactor

int calcColorVolume (int color)
{
	return 
		(color & 0xff) + 
		((color >> 8) & 0xff) + 
		((color >> 16) & 0xff);
}

reactor g_uiReactor ()
{
	g_color = 
		(g_redSlider.m_value << 16) |
		(g_greenSlider.m_value << 8) |
		(g_blueSlider.m_value);

	g_colorLabel.m_text = $"#$(g_color;06x)";		
	g_colorLabel.m_backColor = g_color;
	g_colorLabel.m_color = calcColorVolume (g_color) > 0x180 ? 0x000000 : 0xffffff;

	g_textEdit.m_isEnabled = g_enablePrintCheckBox.m_isChecked;
	g_printButton.m_isEnabled = g_enablePrintCheckBox.m_isChecked;

	onevent g_printButton.m_onClicked ()
	{
		printf ("> %s\n", g_textEdit.m_text);
	}
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// entry point

int main (Layout* mainLayout)
{
	printf ("Creating widgets...\n");

	Layout* hlayout;
	Layout* vlayout;
	
	hlayout = new Layout (Layout.Direction.LeftToRight);

	vlayout = new Layout (Layout.Direction.TopToBottom);
	vlayout.addWidget (new Label ("Red:"));
	vlayout.addWidget (new Label ("Green:"));
	vlayout.addWidget (new Label ("Blue:"));
	hlayout.addLayout (vlayout);

	vlayout = new Layout (Layout.Direction.TopToBottom);
	vlayout.addWidget (g_redSlider = new Slider (0, 255));
	vlayout.addWidget (g_greenSlider = new Slider (0, 255));
	vlayout.addWidget (g_blueSlider = new Slider (0, 255));
	hlayout.addLayout (vlayout);

	mainLayout.addLayout (hlayout);

	g_colorLabel = new Label ("color-label");
	g_colorLabel.m_alignment = Label.Alignment.HCenter | Label.Alignment.VCenter;
	g_colorLabel.setSizePolicy (Widget.SizePolicy.Expanding, Widget.SizePolicy.Expanding);
	mainLayout.addWidget (g_colorLabel);

	mainLayout.addWidget (g_enablePrintCheckBox = new CheckBox ("Enable printing to output"));
	hlayout = new Layout (Layout.Direction.LeftToRight);
	hlayout.addWidget (new Label ("Text:"));
	g_textEdit = new TextEdit;
	g_textEdit.m_text = "sample-text";
	hlayout.addWidget (g_textEdit);
	hlayout.addWidget (g_printButton = new Button ("Print"));
	mainLayout.addLayout (hlayout);

	printf ("Starting UI reactor...\n");
	g_uiReactor.start ();

	return 0;
}

//.............................................................................
