//..............................................................................
//
// HID & HIDMON device lists
//

import "io_usb.jncx"
import "io_UsbDescriptors.jnc"
import "io_hid.jncx"
import "io_HidEnumerator.jnc"
import "io_HidMonEnumerator.jnc"
import "io_AutoHidDb.jnc"
import "ui_ComboBox.jnc"
import "ui_PropertyGrid.jnc"
import "std_String.jnc"
import "std_Array.jnc"

namespace ui {

//! \addtogroup common-ui
//! @{

//..............................................................................

struct HidDeviceEntry {
	io.HidDeviceDesc const* m_deviceDesc;
	char const* m_description;
	char const* m_toolTip;
}

bool isHidDeviceLess(
	HidDeviceEntry const* device1,
	HidDeviceEntry const* device2
) {
	return strcmp(device1.m_description, device2.m_description) < 0;
}

void refreshHidDeviceListUi(
	ComboBox* deviceCombo,
	EnumProperty* deviceProp
) {
	io.HidDeviceDesc const* prevDesc = deviceCombo.m_currentData;
	deviceCombo.clear();

	size_t count;
	io.HidDeviceDesc const* desc = io.enumerateHidDevices(&count);

	std.Array deviceArray;
	deviceArray.setCount(count);
	std.StringBuilder toolTip;
	for (size_t i = 0; i < count; i++, desc = desc.m_next) {
		io.HidUsagePage const* page = io.g_hidDb.getUsagePage(desc.m_usagePage);
		char const* usageName = page.getUsageName(desc.m_usage);

		HidDeviceEntry* entry = new HidDeviceEntry;
		entry.m_deviceDesc = desc;
		entry.m_description = $"%1 by %2 (%3: %4)"(
			desc.m_product,
			desc.m_manufacturer,
			page.m_name,
			usageName
		);

		toolTip =
			"<table>"
			$"<tr><td>Device&nbsp;name:</td><td>%s</td></tr>"
			$"<tr><td>Description:</td><td>%s</td></tr>"
			$"<tr><td>Manufacturer:</td><td>%s</td></tr>"
			$"<tr><td>Vendor ID:</td><td>%04X</td></tr>"
			$"<tr><td>Product ID:</td><td>%04X</td></tr>"
			$"<tr><td>Usage page:</td><td>%s</td></tr>"
			$"<tr><td>Usage:</td><td>%s</td></tr>"
			$"<tr><td>Bus:</td><td>%s</td></tr>"
			$"<tr><td>Interface:</td><td>%d</td></tr>"(
				desc.m_path,
				desc.m_product,
				desc.m_manufacturer,
				desc.m_vendorId,
				desc.m_productId,
				page.m_name,
				usageName,
				typeof(io.HidBusType).getValueString(desc.m_busType),
				desc.m_interfaceId
			);

		if (desc.m_serialNumber)
			toolTip += $"<tr><td>Serial number:</td><td>%s</td></tr>"(desc.m_serialNumber);

		toolTip += "</table>";

		entry.m_toolTip = toolTip.detachString();
		deviceArray[i] = entry;
	}

	deviceArray.sort(isHidDeviceLess);

	ui.EnumPropertyOption* optionArray = new ui.EnumPropertyOption[count];
	ui.EnumPropertyOption* option = optionArray;

	for (size_t i = 0; i < count; i++, option++) {
		HidDeviceEntry* entry = deviceArray[i];
		size_t i = deviceCombo.addItem(entry.m_description, entry.m_deviceDesc);
		deviceCombo.m_itemToolTip[i] = entry.m_toolTip;
		option.m_text = entry.m_description;
		option.m_value = entry.m_deviceDesc;
	}

	deviceProp.setOptions(optionArray, count);

	if (prevDesc) {
		size_t index = findHidDeviceComboIndex(
			deviceCombo,
			prevDesc.m_vendorId,
			prevDesc.m_productId,
			prevDesc.m_path
		);

		deviceCombo.m_currentIndex = index != -1 ? index : 0;
	}
}

size_t findHidDeviceComboIndex(
	ui.ComboBox* deviceCombo,
	uint_t vid,
	uint_t pid,
	char const* path
) {
	size_t bestIndex = -1;

	size_t itemCount = deviceCombo.m_itemCount;
	for (size_t i = 0; i < itemCount; i++) {
		io.HidDeviceDesc const* desc = deviceCombo.m_itemData[i];
		if (desc && desc.m_vendorId == vid && desc.m_productId == pid) {
			if (strcmp(desc.m_path, path) == 0)
				return i; // exact match

			bestIndex = i; // VID/PID match, but different path
		}
	}

	return bestIndex;
}

//..............................................................................

bool isHidMonDeviceLess(
	io.HidMonDeviceDesc const* device1,
	io.HidMonDeviceDesc const* device2
) {
	return
		device1.m_captureDeviceId < device2.m_captureDeviceId ||
		device1.m_captureDeviceId == device2.m_captureDeviceId &&
		device1.m_address < device2.m_address;
}

void refreshHidMonDeviceListUi(
	ComboBox* deviceCombo,
	EnumProperty* deviceProp
) {
	size_t count;
	io.HidMonDeviceDesc const* deviceList = io.enumerateHidMonDevices(&count);

	std.Array deviceArray;
	deviceArray.setCount(count);
	io.HidMonDeviceDesc const* device = deviceList;
	for (size_t i = 0; i < count; i++, device = device.m_next)
		deviceArray[i] = device;

	deviceArray.sort(isHidMonDeviceLess);

	io.HidMonDeviceDesc const* prevDevice = deviceCombo.m_currentData;

	EnumPropertyOption* optionArray = new EnumPropertyOption[count];
	EnumPropertyOption* option = optionArray;

	deviceCombo.clear();

	char const* captureDevicePrefix = sys.g_systemInfo.m_osKind == sys.OsKind.Windows ?
		"USBPcap" :
		"usbmon";

	std.StringBuilder description;
	std.StringBuilder toolTip;

	for (size_t i = 0; i < count; i++, option++) {
		io.HidMonDeviceDesc const* device = deviceArray[i];
		io.HidUsagePage const* page = io.g_hidDb.getUsagePage(device.m_usagePage);
		char const* usageName = page.getUsageName(device.m_usage);

		description = $"%1%2:%(3; 03d).%4 - %5 by %6 (%7: %8)"(
			captureDevicePrefix,
			device.m_captureDeviceId,
			device.m_address,
			device.m_interfaceId,
			device.m_description,
			device.m_manufacturer,
			page.m_name,
			usageName
		);

		toolTip =
			"<table>"
			$"<tr><td>Capture&nbsp;device:</td><td>%1%2:%(3; 03d)</td></tr>"
			$"<tr><td>Description:</td><td>%4</td></tr>"
			$"<tr><td>Manufacturer:</td><td>%5</td></tr>"
			$"<tr><td>Vendor&nbsp;ID:</td><td>%(6; 04X)</td></tr>"
			$"<tr><td>Product&nbsp;ID:</td><td>%(7; 04X)</td></tr>"
			$"<tr><td>Speed:</td><td>%8</td></tr>"
			$"<tr><td>Usage page:</td><td>%9</td></tr>"
			$"<tr><td>Usage:</td><td>%10</td></tr>"
			$"<tr><td>Interface:</td><td>%11</td></tr>"
			$"<tr><td>Endpoint:</td><td>0x%(12; 02X)</td></tr>"(
				captureDevicePrefix,
				device.m_captureDeviceId,
				device.m_address,
				device.m_description,
				device.m_manufacturer,
				device.m_vendorId,
				device.m_productId,
				typeof(io.UsbSpeed).getValueString(device.m_speed),
				page.m_name,
				usageName,
				device.m_interfaceId,
				device.m_endpointId
			);

		if (device.m_driver)
			toolTip += $"<tr><td>Driver:</td><td>$(device.m_driver)</td></tr>";

		if (device.m_manufacturerDescriptor || device.m_productDescriptor || device.m_serialNumberDescriptor) {
			toolTip += $"<tr><td colspan=2><hr></td></tr>";

			if (device.m_productDescriptor)
				toolTip += $"<tr><td>Product:</td><td>$(device.m_productDescriptor)</td></tr>";

			if (device.m_manufacturerDescriptor)
				toolTip += $"<tr><td>Manufacturer:</td><td>$(device.m_manufacturerDescriptor)</td></tr>";

			if (device.m_serialNumberDescriptor)
				toolTip += $"<tr><td>Serial&nbsp;number:</td><td>$(device.m_serialNumberDescriptor)</td></tr>";
		}

		toolTip.append("</table>");

		char const* text = description.detachString();
		size_t j = deviceCombo.addItem(text, device);
		deviceCombo.m_itemToolTip[j] = toolTip.detachString();

		option.m_text = text;
		option.m_value = device;
	}

	deviceProp.setOptions(optionArray, count);

	if (!prevDevice)
		return;

	size_t i = findHidMonDeviceComboIndex(
		deviceCombo,
		prevDevice.m_vendorId,
		prevDevice.m_productId,
		prevDevice.m_captureDeviceId,
		prevDevice.m_address,
		prevDevice.m_interfaceId
	);

	deviceCombo.m_currentIndex = i != -1 ? i : 0;
}

size_t findHidMonDeviceComboIndex(
	ComboBox* deviceCombo,
	uint_t vid,
	uint_t pid,
	uint_t captureDeviceId = -1,
	uint_t address = -1,
	uint_t interfaceId = -1
) {
	size_t bestIndex = -1;

	size_t itemCount = deviceCombo.m_itemCount;
	for (size_t i = 0; i < itemCount; i++) {
		io.HidMonDeviceDesc const* device = deviceCombo.m_itemData[i];
		if (device &&
			device.m_vendorId == vid &&
			device.m_productId == pid
		) {
			if ((captureDeviceId == -1 || device.m_captureDeviceId == captureDeviceId) &&
				(address == -1 || device.m_address == address) &&
				(interfaceId == -1 || device.m_interfaceId == interfaceId)
			)
				return i; // exact match

			bestIndex = i; // VID/PID match, but different address
		}
	}

	return bestIndex;
}

//..............................................................................

//! @}

} // namespace ui
